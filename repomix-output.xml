This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: final66133505/lib/**/*.dart
- Files matching these patterns are excluded: **/*.g.dart
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
final66133505/
  lib/
    core/
      constants/
        db_constants.dart
        firebase_options.dart
        models_constats.dart
      database/
        app_database.dart
        database.dart
        local_datasource.dart
        remote_datasource.dart
        sync_service.dart
        tables.dart
      di/
        injection.dart
      network/
        network_info.dart
      services/
        auto_sync_manager.dart
      theme/
        app_theme.dart
      utils/
        image_storage.dart
        tflite_classifier.dart
    features/
      analysis/
        presentation/
          page/
            ai_scanner.dart
      dashboard/
        presentation/
          page/
            home.dart
      report/
        domain/
          entities/
            incident_report.dart
        presentation/
          page/
            add_report_page.dart
            edit_report_page.dart
            report_detail_page.dart
            report_page.dart
          widgets/
            incident_report_card.dart
    router/
      app_router.dart
    shared/
      layouts/
        main_layout.dart
      widgets/
        splash_screen.dart
    main.dart
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="final66133505/lib/core/constants/db_constants.dart">
/// Database constants used across the storage layer.
///
/// Centralises every magic string / number so changes propagate
/// automatically and typos are caught at compile time.
class DbConstants {
  DbConstants._();

  // ── Database identity ──────────────────────────────────────────────────
  static const String databaseName = 'election_monitor.db';
  static const int databaseVersion = 5;

  // ── Table names ────────────────────────────────────────────────────────
  static const String tablePollingStation = 'polling_station';
  static const String tableViolationType = 'violation_type';
  static const String tableIncidentReport = 'incident_report';

  // ── Firestore collection names ─────────────────────────────────────────
  static const String colPollingStations = 'polling_stations';
  static const String colViolationTypes = 'violation_types';
  static const String colIncidentReports = 'incident_reports';

  // ── Sync configuration ─────────────────────────────────────────────────
  static const int maxRetryCount = 5;
  static const String prefLastSyncTime = 'last_sync_time';

  // ── Firestore batch limit ──────────────────────────────────────────────
  static const int firestoreBatchLimit = 500;

  // ── Sync status values ─────────────────────────────────────────────────
  static const String statusPending = 'pending';
  static const String statusSynced = 'synced';
  static const String statusError = 'error';
}
</file>

<file path="final66133505/lib/core/constants/firebase_options.dart">
// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyAG90WBqr_rNRvzuwsllPJiQ5zCqMU1Lyw',
    appId: '1:143474015125:web:07c81d00185b39976e549c',
    messagingSenderId: '143474015125',
    projectId: 'civil-tempo-414911',
    authDomain: 'civil-tempo-414911.firebaseapp.com',
    storageBucket: 'civil-tempo-414911.firebasestorage.app',
    measurementId: 'G-96V55W14EE',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyD7zwofWCCd---dG9LOL1QKDkvnrxMBCJ0',
    appId: '1:143474015125:android:10d4bec569ff1cf96e549c',
    messagingSenderId: '143474015125',
    projectId: 'civil-tempo-414911',
    storageBucket: 'civil-tempo-414911.firebasestorage.app',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyC-ssrG7kjMTwapWGK7RW7j6qjR2Cg4SaE',
    appId: '1:143474015125:ios:0073045df246b8b06e549c',
    messagingSenderId: '143474015125',
    projectId: 'civil-tempo-414911',
    storageBucket: 'civil-tempo-414911.firebasestorage.app',
    iosBundleId: 'com.phd.exam.flutterFinalExam',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyC-ssrG7kjMTwapWGK7RW7j6qjR2Cg4SaE',
    appId: '1:143474015125:ios:71f7156a98ba7f0a6e549c',
    messagingSenderId: '143474015125',
    projectId: 'civil-tempo-414911',
    storageBucket: 'civil-tempo-414911.firebasestorage.app',
    iosBundleId: 'com.phd.exam',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'AIzaSyAG90WBqr_rNRvzuwsllPJiQ5zCqMU1Lyw',
    appId: '1:143474015125:web:f61ffef6ad713caf6e549c',
    messagingSenderId: '143474015125',
    projectId: 'civil-tempo-414911',
    authDomain: 'civil-tempo-414911.firebaseapp.com',
    storageBucket: 'civil-tempo-414911.firebasestorage.app',
    measurementId: 'G-LNEH2D5ZX3',
  );
}
</file>

<file path="final66133505/lib/core/constants/models_constats.dart">
class ModelsConstats {
  static const String aiv1 = "aiv1";
}
</file>

<file path="final66133505/lib/core/database/app_database.dart">
import 'package:logging/logging.dart';
import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';

import '../constants/db_constants.dart';
import 'tables.dart';

/// Singleton wrapper around the [sqflite] database instance.
///
/// Guarantees:
///   • Lazy initialisation (DB is only opened on first access).
///   • Foreign keys enabled via `PRAGMA foreign_keys = ON`.
///   • WAL journal mode for better concurrent-read performance.
///   • All tables + seed data created inside [_onCreate].
///
/// Usage:
/// ```dart
/// final db = await AppDatabase.instance.database;
/// ```
class AppDatabase {
  AppDatabase._();

  static final AppDatabase _instance = AppDatabase._();

  /// The singleton accessor.
  static AppDatabase get instance => _instance;

  static final _log = Logger('AppDatabase');

  Database? _database;

  /// Returns the opened [Database], creating it on first call.
  ///
  /// If the previous open attempt failed, retries automatically.
  Future<Database> get database async {
    if (_database != null && _database!.isOpen) return _database!;
    _database = await _initDatabase();
    return _database!;
  }

  // ── Lifecycle ──────────────────────────────────────────────────────────

  Future<Database> _initDatabase() async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, DbConstants.databaseName);

    _log.info('Opening database at $path');

    return openDatabase(
      path,
      version: DbConstants.databaseVersion,
      onCreate: _onCreate,
      onUpgrade: _onUpgrade,
      onConfigure: _onConfigure,
    );
  }

  /// Called before [_onCreate] / [_onUpgrade] — enable foreign keys.
  ///
  /// Note: WAL journal mode is NOT set here because Android's sqflite
  /// already uses WAL by default and does not allow changing the journal
  /// mode via a raw PRAGMA statement inside `onConfigure`.
  Future<void> _onConfigure(Database db) async {
    await db.execute('PRAGMA foreign_keys = ON');
    _log.fine('PRAGMA foreign_keys enabled');
  }

  /// Called once when the database is first created.
  Future<void> _onCreate(Database db, int version) async {
    _log.info('Creating database (version $version)');

    final batch = db.batch();
    for (final sql in Tables.allCreateStatements) {
      batch.execute(sql);
    }
    await batch.commit(noResult: true);

    _log.info('Database created with seed data');
  }

  /// Destructive migration: drops all tables and re-creates them.
  ///
  /// This is acceptable during early development. For production, add
  /// incremental ALTER TABLE statements per version bump instead.
  Future<void> _onUpgrade(Database db, int oldVersion, int newVersion) async {
    _log.info('Upgrading database from v$oldVersion → v$newVersion');

    // Drop existing tables (order matters due to FK constraints).
    await db.execute('DROP TABLE IF EXISTS ${DbConstants.tableIncidentReport}');
    await db.execute('DROP TABLE IF EXISTS ${DbConstants.tableViolationType}');
    await db.execute('DROP TABLE IF EXISTS ${DbConstants.tablePollingStation}');

    _log.info('Old tables dropped — recreating with new schema');
    await _onCreate(db, newVersion);
  }

  // ── Utility ────────────────────────────────────────────────────────────

  /// Closes the database (useful for testing or graceful shutdown).
  Future<void> close() async {
    final db = _database;
    if (db != null && db.isOpen) {
      await db.close();
      _database = null;
      _log.info('Database closed');
    }
  }

  /// Drops every table and re-creates the schema with fresh seed data.
  ///
  /// Useful for development / debug reset from the UI.
  Future<void> resetDatabase() async {
    _log.info('resetDatabase called — wiping and reseeding…');

    final db = await database;

    // Temporarily disable FK enforcement so drops succeed in any order.
    await db.execute('PRAGMA foreign_keys = OFF');

    await db.execute('DROP TABLE IF EXISTS ${DbConstants.tableIncidentReport}');
    await db.execute('DROP TABLE IF EXISTS ${DbConstants.tableViolationType}');
    await db.execute('DROP TABLE IF EXISTS ${DbConstants.tablePollingStation}');

    // Drop any leftover indices.
    await db.execute('DROP INDEX IF EXISTS idx_report_station');
    await db.execute('DROP INDEX IF EXISTS idx_report_type');
    await db.execute('DROP INDEX IF EXISTS idx_report_timestamp');
    await db.execute('DROP INDEX IF EXISTS idx_report_status');

    // Recreate everything from scratch (same as first install).
    final batch = db.batch();
    for (final sql in Tables.allCreateStatements) {
      batch.execute(sql);
    }
    await batch.commit(noResult: true);

    // Re-enable FK enforcement.
    await db.execute('PRAGMA foreign_keys = ON');

    _log.info('resetDatabase complete — seed data loaded ✓');
  }
}
</file>

<file path="final66133505/lib/core/database/database.dart">
/// Barrel export for the entire storage layer.
///
/// Import this single file to access:
///   • Entity classes
///   • Data sources
///   • Repositories (via injection.dart)
///   • Sync service
///   • Database singleton
library database;

export 'app_database.dart';
export 'local_datasource.dart'
    show
        PollingStationEntity,
        ViolationTypeEntity,
        IncidentReportEntity,
        LocalDataSource;
export 'remote_datasource.dart' show RemoteDataSource;
export 'sync_service.dart' show SyncService;
export '../services/auto_sync_manager.dart'
    show AutoSyncManager, SyncState, SyncStatus;
</file>

<file path="final66133505/lib/core/database/local_datasource.dart">
import 'package:logging/logging.dart';
import 'package:sqflite/sqflite.dart';

import '../constants/db_constants.dart';
import 'app_database.dart';

// ═══════════════════════════════════════════════════════════════════════════════
// Entity classes (plain Dart objects — NO Firestore / sync logic)
// ═══════════════════════════════════════════════════════════════════════════════

/// Represents a row in `polling_station`.
class PollingStationEntity {
  final int stationId;
  final String stationName;
  final String zone;
  final String province;
  final int updatedAt;
  final bool isDeleted;
  final bool isSynced;

  const PollingStationEntity({
    required this.stationId,
    required this.stationName,
    required this.zone,
    required this.province,
    required this.updatedAt,
    this.isDeleted = false,
    this.isSynced = true,
  });

  factory PollingStationEntity.fromMap(Map<String, dynamic> map) {
    return PollingStationEntity(
      stationId: map['station_id'] as int,
      stationName: map['station_name'] as String,
      zone: map['zone'] as String,
      province: map['province'] as String,
      updatedAt: map['updated_at'] as int,
      isDeleted: (map['is_deleted'] as int? ?? 0) == 1,
      isSynced: (map['is_synced'] as int? ?? 1) == 1,
    );
  }

  Map<String, dynamic> toMap() => {
    'station_id': stationId,
    'station_name': stationName,
    'zone': zone,
    'province': province,
    'updated_at': updatedAt,
    'is_deleted': isDeleted ? 1 : 0,
    'is_synced': isSynced ? 1 : 0,
  };
}

/// Represents a row in `violation_type`.
class ViolationTypeEntity {
  final int typeId;
  final String typeName;
  final String severity;
  final int updatedAt;
  final bool isDeleted;
  final bool isSynced;

  const ViolationTypeEntity({
    required this.typeId,
    required this.typeName,
    required this.severity,
    required this.updatedAt,
    this.isDeleted = false,
    this.isSynced = true,
  });

  factory ViolationTypeEntity.fromMap(Map<String, dynamic> map) {
    return ViolationTypeEntity(
      typeId: map['type_id'] as int,
      typeName: map['type_name'] as String,
      severity: map['severity'] as String,
      updatedAt: map['updated_at'] as int,
      isDeleted: (map['is_deleted'] as int? ?? 0) == 1,
      isSynced: (map['is_synced'] as int? ?? 1) == 1,
    );
  }

  Map<String, dynamic> toMap() => {
    'type_id': typeId,
    'type_name': typeName,
    'severity': severity,
    'updated_at': updatedAt,
    'is_deleted': isDeleted ? 1 : 0,
    'is_synced': isSynced ? 1 : 0,
  };
}

/// Represents a row in `incident_report`.
class IncidentReportEntity {
  /// UUID string — generated client-side.
  final int? reportId;
  final int stationId;
  final int typeId;
  final String reporterName;
  final String description;
  final String? evidencePhoto;

  /// Unix millisecond timestamp stored as INTEGER.
  final String timestamp;

  final String? aiResult;
  final double aiConfidence;
  final String userId;
  final String deviceId;

  /// `pending` | `synced` | `error`
  final String status;
  final bool isDeleted;
  final int updatedAt;
  final int? syncedAt;
  final int retryCount;
  final String? lastError;

  /// Convenience getter used by the UI layer.
  bool get isSynced => status == DbConstants.statusSynced;

  const IncidentReportEntity({
    this.reportId,
    required this.stationId,
    required this.typeId,
    required this.reporterName,
    required this.description,
    this.evidencePhoto,
    required this.timestamp,
    this.aiResult,
    this.aiConfidence = 0.0,
    this.userId = '',
    this.deviceId = '',
    this.status = DbConstants.statusPending,
    this.isDeleted = false,
    this.updatedAt = 0,
    this.syncedAt,
    this.retryCount = 0,
    this.lastError,
  });

  factory IncidentReportEntity.fromMap(Map<String, dynamic> map) {
    return IncidentReportEntity(
      reportId: map['report_id'] as int?,
      stationId: map['station_id'] as int,
      typeId: map['type_id'] as int,
      reporterName: (map['reporter_name'] as String?) ?? '',
      description: (map['description'] as String?) ?? '',
      evidencePhoto: map['evidence_photo'] as String?,
      timestamp: _parseTimestamp(map['timestamp']),
      aiResult: map['ai_result'] as String?,
      aiConfidence: (map['ai_confidence'] as num?)?.toDouble() ?? 0.0,
      userId: (map['user_id'] as String?) ?? '',
      deviceId: (map['device_id'] as String?) ?? '',
      status: (map['status'] as String?) ?? DbConstants.statusPending,
      isDeleted: (map['is_deleted'] as int? ?? 0) == 1,
      updatedAt: (map['updated_at'] as int?) ?? 0,
      syncedAt: map['synced_at'] as int?,
      retryCount: (map['retry_count'] as int?) ?? 0,
      lastError: map['last_error'] as String?,
    );
  }

  /// Handles both INTEGER (Unix ms) and legacy TEXT timestamps.
  static String _parseTimestamp(dynamic value) {
    if (value is int) {
      return DateTime.fromMillisecondsSinceEpoch(value).toIso8601String();
    }
    return (value as String?) ?? DateTime.now().toIso8601String();
  }

  Map<String, dynamic> toMap() {
    final map = <String, dynamic>{
      'station_id': stationId,
      'type_id': typeId,
      'reporter_name': reporterName,
      'description': description,
      'evidence_photo': evidencePhoto,
      'timestamp': _timestampToInt(),
      'ai_result': aiResult,
      'ai_confidence': aiConfidence,
      'user_id': userId,
      'device_id': deviceId,
      'status': status,
      'is_deleted': isDeleted ? 1 : 0,
      'updated_at': updatedAt,
      'synced_at': syncedAt,
      'retry_count': retryCount,
      'last_error': lastError,
    };
    if (reportId != null) map['report_id'] = reportId;
    return map;
  }

  /// Converts the ISO-8601 / custom timestamp string back to Unix ms.
  int _timestampToInt() {
    final parsed = DateTime.tryParse(timestamp);
    if (parsed != null) return parsed.millisecondsSinceEpoch;
    return DateTime.now().millisecondsSinceEpoch;
  }

  /// Returns a copy with selected fields overridden.
  IncidentReportEntity copyWith({
    int? reportId,
    int? stationId,
    int? typeId,
    String? reporterName,
    String? description,
    String? evidencePhoto,
    String? timestamp,
    String? aiResult,
    double? aiConfidence,
    String? userId,
    String? deviceId,
    String? status,
    bool? isDeleted,
    int? updatedAt,
    int? syncedAt,
    int? retryCount,
    String? lastError,
  }) {
    return IncidentReportEntity(
      reportId: reportId ?? this.reportId,
      stationId: stationId ?? this.stationId,
      typeId: typeId ?? this.typeId,
      reporterName: reporterName ?? this.reporterName,
      description: description ?? this.description,
      evidencePhoto: evidencePhoto ?? this.evidencePhoto,
      timestamp: timestamp ?? this.timestamp,
      aiResult: aiResult ?? this.aiResult,
      aiConfidence: aiConfidence ?? this.aiConfidence,
      userId: userId ?? this.userId,
      deviceId: deviceId ?? this.deviceId,
      status: status ?? this.status,
      isDeleted: isDeleted ?? this.isDeleted,
      updatedAt: updatedAt ?? this.updatedAt,
      syncedAt: syncedAt ?? this.syncedAt,
      retryCount: retryCount ?? this.retryCount,
      lastError: lastError ?? this.lastError,
    );
  }
}

// ═══════════════════════════════════════════════════════════════════════════════
// Local Data Source — pure SQLite operations, NO sync / Firestore logic
// ═══════════════════════════════════════════════════════════════════════════════

/// Low-level CRUD operations against the local SQLite database.
///
/// **Rules:**
///   • Never performs network calls.
///   • Never resolves conflicts — that's the repository / sync service's job.
///   • Every public method receives or returns plain entity objects.
class LocalDataSource {
  LocalDataSource({required this.appDatabase});

  final AppDatabase appDatabase;
  static final _log = Logger('LocalDataSource');

  Future<Database> get _db => appDatabase.database;

  // ─────────────────────────────────────────────────────────────────────────
  // Polling Station
  // ─────────────────────────────────────────────────────────────────────────

  Future<List<PollingStationEntity>> getAllStations() async {
    final db = await _db;
    final rows = await db.query(
      DbConstants.tablePollingStation,
      where: 'is_deleted = ?',
      whereArgs: [0],
      orderBy: 'station_id ASC',
    );
    _log.fine('getAllStations → ${rows.length} rows');
    return rows.map(PollingStationEntity.fromMap).toList();
  }

  Future<PollingStationEntity?> getStationById(int id) async {
    final db = await _db;
    final rows = await db.query(
      DbConstants.tablePollingStation,
      where: 'station_id = ? AND is_deleted = 0',
      whereArgs: [id],
      limit: 1,
    );
    return rows.isEmpty ? null : PollingStationEntity.fromMap(rows.first);
  }

  Future<void> upsertStation(PollingStationEntity entity) async {
    final db = await _db;
    await db.insert(
      DbConstants.tablePollingStation,
      entity.toMap(),
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
    _log.fine('upsertStation id=${entity.stationId}');
  }

  /// Inserts a new station without a pre-set ID and returns the assigned ID.
  Future<int> insertNewStation(PollingStationEntity entity) async {
    final db = await _db;
    final map = entity.toMap()..remove('station_id');
    final id = await db.insert(
      DbConstants.tablePollingStation,
      map,
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
    _log.fine('insertNewStation → id=$id');
    return id;
  }

  Future<void> upsertStations(List<PollingStationEntity> entities) async {
    final db = await _db;
    final batch = db.batch();
    for (final e in entities) {
      batch.insert(
        DbConstants.tablePollingStation,
        e.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
    }
    await batch.commit(noResult: true);
    _log.fine('upsertStations → ${entities.length} rows');
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Violation Type
  // ─────────────────────────────────────────────────────────────────────────

  Future<List<ViolationTypeEntity>> getAllTypes() async {
    final db = await _db;
    final rows = await db.query(
      DbConstants.tableViolationType,
      where: 'is_deleted = ?',
      whereArgs: [0],
      orderBy: 'type_id ASC',
    );
    _log.fine('getAllTypes → ${rows.length} rows');
    return rows.map(ViolationTypeEntity.fromMap).toList();
  }

  Future<ViolationTypeEntity?> getTypeById(int id) async {
    final db = await _db;
    final rows = await db.query(
      DbConstants.tableViolationType,
      where: 'type_id = ? AND is_deleted = 0',
      whereArgs: [id],
      limit: 1,
    );
    return rows.isEmpty ? null : ViolationTypeEntity.fromMap(rows.first);
  }

  Future<void> upsertType(ViolationTypeEntity entity) async {
    final db = await _db;
    await db.insert(
      DbConstants.tableViolationType,
      entity.toMap(),
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
    _log.fine('upsertType id=${entity.typeId}');
  }

  /// Inserts a new type without a pre-set ID and returns the assigned ID.
  Future<int> insertNewType(ViolationTypeEntity entity) async {
    final db = await _db;
    final map = entity.toMap()..remove('type_id');
    final id = await db.insert(
      DbConstants.tableViolationType,
      map,
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
    _log.fine('insertNewType → id=$id');
    return id;
  }

  Future<void> upsertTypes(List<ViolationTypeEntity> entities) async {
    final db = await _db;
    final batch = db.batch();
    for (final e in entities) {
      batch.insert(
        DbConstants.tableViolationType,
        e.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
    }
    await batch.commit(noResult: true);
    _log.fine('upsertTypes → ${entities.length} rows');
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Incident Report
  // ─────────────────────────────────────────────────────────────────────────

  Future<List<IncidentReportEntity>> getAllReports() async {
    final db = await _db;
    final rows = await db.query(
      DbConstants.tableIncidentReport,
      where: 'is_deleted = ?',
      whereArgs: [0],
      orderBy: 'timestamp DESC',
    );
    _log.fine('getAllReports → ${rows.length} rows');
    return rows.map(IncidentReportEntity.fromMap).toList();
  }

  Future<IncidentReportEntity?> getReportById(int id) async {
    final db = await _db;
    final rows = await db.query(
      DbConstants.tableIncidentReport,
      where: 'report_id = ? AND is_deleted = 0',
      whereArgs: [id],
      limit: 1,
    );
    return rows.isEmpty ? null : IncidentReportEntity.fromMap(rows.first);
  }

  /// Like [getReportById] but also returns soft-deleted rows.
  /// Used during pull-sync to avoid duplicate INSERT on already-existing rows.
  Future<IncidentReportEntity?> getReportByIdAny(int id) async {
    final db = await _db;
    final rows = await db.query(
      DbConstants.tableIncidentReport,
      where: 'report_id = ?',
      whereArgs: [id],
      limit: 1,
    );
    return rows.isEmpty ? null : IncidentReportEntity.fromMap(rows.first);
  }

  /// Inserts a new report. SQLite auto-assigns report_id (AUTOINCREMENT).
  /// Returns the auto-assigned integer ID.
  Future<int> insertReport(IncidentReportEntity entity) async {
    final db = await _db;
    final rowId = await db.insert(
      DbConstants.tableIncidentReport,
      entity.toMap(),
      conflictAlgorithm: ConflictAlgorithm.abort,
    );
    _log.fine('insertReport id=$rowId');
    return rowId;
  }

  /// Full row replacement (used by conflict merge).
  Future<void> updateReport(IncidentReportEntity entity) async {
    final db = await _db;
    await db.update(
      DbConstants.tableIncidentReport,
      entity.toMap(),
      where: 'report_id = ?',
      whereArgs: [entity.reportId],
    );
    _log.fine('updateReport id=${entity.reportId}');
  }

  /// Marks a report as synced after successful upload.
  Future<void> markAsSynced(int reportId, int syncedAt) async {
    final db = await _db;
    await db.update(
      DbConstants.tableIncidentReport,
      {
        'status': DbConstants.statusSynced,
        'synced_at': syncedAt,
        'retry_count': 0,
        'last_error': null,
      },
      where: 'report_id = ?',
      whereArgs: [reportId],
    );
    _log.fine('markAsSynced id=$reportId');
  }

  /// Records a sync failure for retry tracking.
  Future<void> markSyncError(int reportId, int retryCount, String error) async {
    final db = await _db;
    await db.update(
      DbConstants.tableIncidentReport,
      {
        'status': DbConstants.statusError,
        'retry_count': retryCount,
        'last_error': error,
      },
      where: 'report_id = ?',
      whereArgs: [reportId],
    );
    _log.fine('markSyncError id=$reportId retry=$retryCount');
  }

  /// Returns reports that need to be pushed to Firestore.
  Future<List<IncidentReportEntity>> getPendingReports() async {
    final db = await _db;
    final rows = await db.query(
      DbConstants.tableIncidentReport,
      where:
          "(status = ? OR status = ?) AND is_deleted = 0 AND retry_count < ?",
      whereArgs: [
        DbConstants.statusPending,
        DbConstants.statusError,
        DbConstants.maxRetryCount,
      ],
      orderBy: 'updated_at ASC',
    );
    _log.fine('getPendingReports → ${rows.length} rows');
    return rows.map(IncidentReportEntity.fromMap).toList();
  }

  /// Soft-deletes a report (sets is_deleted = 1, status = pending).
  Future<void> softDeleteReport(int reportId) async {
    final db = await _db;
    final now = DateTime.now().millisecondsSinceEpoch;
    await db.update(
      DbConstants.tableIncidentReport,
      {'is_deleted': 1, 'updated_at': now, 'status': DbConstants.statusPending},
      where: 'report_id = ?',
      whereArgs: [reportId],
    );
    _log.fine('softDeleteReport id=$reportId');
  }

  /// Permanently removes a report row from SQLite.
  Future<void> hardDeleteReport(int reportId) async {
    final db = await _db;
    await db.delete(
      DbConstants.tableIncidentReport,
      where: 'report_id = ?',
      whereArgs: [reportId],
    );
    _log.fine('hardDeleteReport id=$reportId');
  }

  /// Count of reports that have not been synced yet.
  Future<int> getUnsyncedReportCount() async {
    final db = await _db;
    final result = await db.rawQuery(
      'SELECT COUNT(*) as cnt FROM ${DbConstants.tableIncidentReport} '
      "WHERE status != ? AND is_deleted = 0",
      [DbConstants.statusSynced],
    );
    return Sqflite.firstIntValue(result) ?? 0;
  }

  /// Returns the most recent `updated_at` value from all reports.
  Future<int> getLatestReportUpdatedAt() async {
    final db = await _db;
    final result = await db.rawQuery(
      'SELECT MAX(updated_at) as max_ts FROM ${DbConstants.tableIncidentReport}',
    );
    return (result.first['max_ts'] as int?) ?? 0;
  }
}
</file>

<file path="final66133505/lib/core/database/remote_datasource.dart">
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:logging/logging.dart';

import '../constants/db_constants.dart';
import 'local_datasource.dart';

/// Handles all Cloud Firestore read / write operations.
///
/// **Rules:**
///   • Never touches SQLite.
///   • Never performs conflict resolution — the sync service owns that.
///   • Works exclusively with maps / entity objects.
class RemoteDataSource {
  RemoteDataSource({FirebaseFirestore? firestore})
    : _firestore = firestore ?? FirebaseFirestore.instance;

  final FirebaseFirestore _firestore;
  static final _log = Logger('RemoteDataSource');

  // ─────────────────────────────────────────────────────────────────────────
  // Polling Station (pull-only)
  // ─────────────────────────────────────────────────────────────────────────

  /// Fetches all polling stations from Firestore.
  Future<List<PollingStationEntity>> fetchAllStations() async {
    final snap = await _firestore
        .collection(DbConstants.colPollingStations)
        .get();
    _log.fine('fetchAllStations → ${snap.docs.length} docs');
    return snap.docs.map((doc) {
      final data = doc.data();
      data['station_id'] = int.tryParse(doc.id) ?? data['station_id'];
      return PollingStationEntity.fromMap(data);
    }).toList();
  }

  /// Pushes a list of polling stations to Firestore (seed / initial push).
  Future<void> pushStations(List<PollingStationEntity> entities) async {
    final batches = _chunkList(entities, DbConstants.firestoreBatchLimit);
    for (final chunk in batches) {
      final batch = _firestore.batch();
      for (final e in chunk) {
        final ref = _firestore
            .collection(DbConstants.colPollingStations)
            .doc('${e.stationId}');
        batch.set(ref, e.toMap(), SetOptions(merge: true));
      }
      await batch.commit();
    }
    _log.info('pushStations → ${entities.length} docs');
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Violation Type (pull-only)
  // ─────────────────────────────────────────────────────────────────────────

  /// Fetches all violation types from Firestore.
  Future<List<ViolationTypeEntity>> fetchAllTypes() async {
    final snap = await _firestore
        .collection(DbConstants.colViolationTypes)
        .get();
    _log.fine('fetchAllTypes → ${snap.docs.length} docs');
    return snap.docs.map((doc) {
      final data = doc.data();
      data['type_id'] = int.tryParse(doc.id) ?? data['type_id'];
      return ViolationTypeEntity.fromMap(data);
    }).toList();
  }

  /// Pushes a list of violation types to Firestore (seed / initial push).
  Future<void> pushTypes(List<ViolationTypeEntity> entities) async {
    final batches = _chunkList(entities, DbConstants.firestoreBatchLimit);
    for (final chunk in batches) {
      final batch = _firestore.batch();
      for (final e in chunk) {
        final ref = _firestore
            .collection(DbConstants.colViolationTypes)
            .doc('${e.typeId}');
        batch.set(ref, e.toMap(), SetOptions(merge: true));
      }
      await batch.commit();
    }
    _log.info('pushTypes → ${entities.length} docs');
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Incident Report (bidirectional sync)
  // ─────────────────────────────────────────────────────────────────────────

  /// Uploads a single report to Firestore.
  Future<void> uploadReport(IncidentReportEntity entity) async {
    if (entity.reportId == null) {
      throw ArgumentError('report_id must not be null when uploading');
    }
    final ref = _firestore
        .collection(DbConstants.colIncidentReports)
        .doc('${entity.reportId}');
    await ref.set(entity.toMap(), SetOptions(merge: true));
    _log.fine('uploadReport id=${entity.reportId}');
  }

  /// Updates a remote report document (e.g. soft-delete propagation).
  Future<void> updateRemoteReport(IncidentReportEntity entity) async {
    if (entity.reportId == null) return;
    final ref = _firestore
        .collection(DbConstants.colIncidentReports)
        .doc('${entity.reportId}');
    await ref.update(entity.toMap());
    _log.fine('updateRemoteReport id=${entity.reportId}');
  }

  /// Fetches remote reports modified since [sinceTimestamp] (Unix ms).
  ///
  /// Returns at most [limit] documents per page. Pass `null` for first page.
  Future<List<IncidentReportEntity>> fetchReportsSince(
    int sinceTimestamp, {
    int limit = DbConstants.firestoreBatchLimit,
  }) async {
    final snap = await _firestore
        .collection(DbConstants.colIncidentReports)
        .where('updated_at', isGreaterThan: sinceTimestamp)
        .orderBy('updated_at')
        .limit(limit)
        .get();
    _log.fine('fetchReportsSince($sinceTimestamp) → ${snap.docs.length} docs');
    return snap.docs.map((doc) {
      final data = doc.data();
      data['report_id'] = int.tryParse(doc.id);
      return IncidentReportEntity.fromMap(data);
    }).toList();
  }

  /// Fetches all reports from Firestore (full pull).
  Future<List<IncidentReportEntity>> fetchAllReports() async {
    final snap = await _firestore
        .collection(DbConstants.colIncidentReports)
        .get();
    _log.fine('fetchAllReports → ${snap.docs.length} docs');
    return snap.docs.map((doc) {
      final data = doc.data();
      data['report_id'] = int.tryParse(doc.id);
      return IncidentReportEntity.fromMap(data);
    }).toList();
  }

  /// Deletes a report document from Firestore permanently.
  Future<void> deleteRemoteReport(int reportId) async {
    try {
      await _firestore
          .collection(DbConstants.colIncidentReports)
          .doc('$reportId')
          .delete();
      _log.fine('deleteRemoteReport id=$reportId');
    } catch (e, s) {
      _log.warning('deleteRemoteReport failed id=$reportId', e, s);
      rethrow;
    }
  }

  /// Batch-uploads multiple reports using Firestore batched writes.
  Future<void> uploadReports(List<IncidentReportEntity> entities) async {
    final chunks = _chunkList(entities, DbConstants.firestoreBatchLimit);
    for (final chunk in chunks) {
      final batch = _firestore.batch();
      for (final e in chunk) {
        if (e.reportId == null) continue;
        final ref = _firestore
            .collection(DbConstants.colIncidentReports)
            .doc('${e.reportId}');
        batch.set(ref, e.toMap(), SetOptions(merge: true));
      }
      await batch.commit();
    }
    _log.info('uploadReports → ${entities.length} docs');
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Helpers
  // ─────────────────────────────────────────────────────────────────────────

  /// Splits a list into chunks of at most [size] elements.
  List<List<T>> _chunkList<T>(List<T> list, int size) {
    final chunks = <List<T>>[];
    for (var i = 0; i < list.length; i += size) {
      final end = (i + size > list.length) ? list.length : i + size;
      chunks.add(list.sublist(i, end));
    }
    return chunks;
  }
}
</file>

<file path="final66133505/lib/core/database/sync_service.dart">
import 'dart:async';
import 'dart:math';

import 'package:logging/logging.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../constants/db_constants.dart';
import '../network/network_info.dart';
import 'local_datasource.dart';
import 'remote_datasource.dart';

/// Orchestrates bidirectional synchronisation between SQLite and Firestore.
///
/// **Algorithm (on every [syncAll] call):**
///   1. Check connectivity.
///   2. Pull remote changes (since last sync).
///   3. Merge via Last-Writer-Wins (LWW) using `updated_at`.
///   4. Push local pending reports with exponential retry.
///   5. Update `synced_at`, `status`, and persisted `last_sync_time`.
///
/// Master-data tables (`polling_station`, `violation_type`) are pull-only.
class SyncService {
  SyncService({
    required this.localDataSource,
    required this.remoteDataSource,
    required this.networkInfo,
  });

  final LocalDataSource localDataSource;
  final RemoteDataSource remoteDataSource;
  final NetworkInfo networkInfo;

  static final _log = Logger('SyncService');

  StreamSubscription<bool>? _connectivitySub;

  // ═══════════════════════════════════════════════════════════════════════════
  // Lifecycle
  // ═══════════════════════════════════════════════════════════════════════════

  /// Call once at app startup. Subscribes to connectivity changes and
  /// triggers a sync whenever the device comes back online.
  Future<void> initialize() async {
    _log.info('SyncService initializing…');

    // Initial sync if online.
    final connected = await networkInfo.isConnected;
    if (connected) {
      try {
        await syncAll();
      } catch (e, s) {
        _log.warning('Initial sync failed (non-fatal)', e, s);
      }
    }

    // Auto-sync on connectivity restore.
    _connectivitySub = networkInfo.onConnectivityChanged.listen((online) {
      if (online) {
        _log.info('Connectivity restored → triggering sync');
        syncAll().catchError((e, s) {
          _log.warning('Auto-sync failed', e, s);
        });
      }
    });

    _log.info('SyncService initialized');
  }

  /// Cancels the connectivity listener (e.g. on app teardown).
  void dispose() {
    _connectivitySub?.cancel();
    _connectivitySub = null;
    _log.info('SyncService disposed');
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // Full sync cycle
  // ═══════════════════════════════════════════════════════════════════════════

  /// **Startup pull-first bootstrap.**
  ///
  /// Called once on app open — always pulls the latest data from Firestore
  /// into SQLite before the UI is shown. This ensures the user always sees
  /// up-to-date data from other devices.
  ///
  /// Order:
  ///   1. Pull reference data (stations → types).
  ///   2. Pull & merge all incident reports.
  ///
  /// Safe to call when offline — gracefully skips with a log warning.
  Future<void> pullFromFirestoreOnStartup() async {
    if (!await networkInfo.isConnected) {
      _log.info(
        'pullFromFirestoreOnStartup skipped — offline, using local data',
      );
      return;
    }

    _log.info('━━━ pullFromFirestoreOnStartup START ━━━');

    try {
      await _pullStations();
      await _pullViolationTypes();
      await _pullAndMergeReports();
      await _saveLastSyncTime(DateTime.now().millisecondsSinceEpoch);
      _log.info('━━━ pullFromFirestoreOnStartup COMPLETE ━━━');
    } catch (e, s) {
      _log.warning('pullFromFirestoreOnStartup failed (non-fatal)', e, s);
      // Non-fatal — app continues with whatever is in local SQLite.
    }
  }

  /// Runs the complete Pull → Merge → Push cycle.
  Future<void> syncAll() async {
    if (!await networkInfo.isConnected) {
      _log.info('syncAll skipped — offline');
      return;
    }

    _log.info('━━━ syncAll START ━━━');

    try {
      // 1. Pull master data (reference tables).
      await _pullStations();
      await _pullViolationTypes();

      // 2. Pull + merge incident reports.
      await _pullAndMergeReports();

      // 3. Push local pending reports.
      await _pushPendingReports();

      // 4. Persist last sync time.
      await _saveLastSyncTime(DateTime.now().millisecondsSinceEpoch);

      _log.info('━━━ syncAll COMPLETE ━━━');
    } catch (e, s) {
      _log.severe('syncAll failed', e, s);
      rethrow;
    }
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Pull — Master Data
  // ─────────────────────────────────────────────────────────────────────────

  Future<void> _pullStations() async {
    try {
      final remote = await remoteDataSource.fetchAllStations();
      if (remote.isNotEmpty) {
        await localDataSource.upsertStations(remote);
        _log.info('Pulled ${remote.length} polling stations');
      }
    } catch (e, s) {
      _log.warning('_pullStations failed (non-fatal)', e, s);
    }
  }

  Future<void> _pullViolationTypes() async {
    try {
      final remote = await remoteDataSource.fetchAllTypes();
      if (remote.isNotEmpty) {
        await localDataSource.upsertTypes(remote);
        _log.info('Pulled ${remote.length} violation types');
      }
    } catch (e, s) {
      _log.warning('_pullViolationTypes failed (non-fatal)', e, s);
    }
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Pull + Merge — Incident Reports (LWW conflict resolution)
  // ─────────────────────────────────────────────────────────────────────────

  Future<void> _pullAndMergeReports() async {
    try {
      final lastSync = await _getLastSyncTime();
      final remoteReports = await remoteDataSource.fetchReportsSince(lastSync);

      if (remoteReports.isEmpty) {
        _log.fine('No remote report changes since $lastSync');
        return;
      }

      _log.info('Pulled ${remoteReports.length} remote report(s) to merge');

      for (final remote in remoteReports) {
        if (remote.reportId == null) continue;

        final local = await localDataSource.getReportById(remote.reportId!);

        if (local == null) {
          // New report from another device — insert locally.
          await localDataSource.insertReport(
            remote.copyWith(
              status: DbConstants.statusSynced,
              syncedAt: DateTime.now().millisecondsSinceEpoch,
            ),
          );
          _log.fine('Inserted new remote report ${remote.reportId}');
        } else {
          // ── LWW conflict resolution ────────────────────────────────
          if (remote.updatedAt > local.updatedAt) {
            // Remote wins — overwrite local.
            await localDataSource.updateReport(
              remote.copyWith(
                status: DbConstants.statusSynced,
                syncedAt: DateTime.now().millisecondsSinceEpoch,
              ),
            );
            _log.fine(
              'LWW: remote wins for ${remote.reportId} '
              '(remote=${remote.updatedAt} > local=${local.updatedAt})',
            );
          } else {
            // Local wins — keep local, will be pushed.
            _log.fine(
              'LWW: local wins for ${remote.reportId} '
              '(local=${local.updatedAt} >= remote=${remote.updatedAt})',
            );
          }
        }
      }
    } catch (e, s) {
      _log.warning('_pullAndMergeReports failed', e, s);
    }
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Push — Pending Reports (exponential retry)
  // ─────────────────────────────────────────────────────────────────────────

  Future<void> _pushPendingReports() async {
    final pending = await localDataSource.getPendingReports();
    if (pending.isEmpty) {
      _log.fine('No pending reports to push');
      return;
    }

    _log.info('Pushing ${pending.length} pending report(s)');

    for (final report in pending) {
      if (report.reportId == null) continue;
      await _pushSingleReport(report);
    }
  }

  Future<void> _pushSingleReport(IncidentReportEntity report) async {
    final retries = report.retryCount;
    if (retries >= DbConstants.maxRetryCount) {
      _log.warning(
        'Skipping ${report.reportId} — max retries (${DbConstants.maxRetryCount}) reached',
      );
      return;
    }

    // Exponential backoff delay (skip on first attempt).
    if (retries > 0) {
      final delay = Duration(seconds: pow(2, retries).toInt());
      _log.fine('Retry #$retries for ${report.reportId} — waiting $delay');
      await Future.delayed(delay);
    }

    try {
      await remoteDataSource.uploadReport(report);
      final now = DateTime.now().millisecondsSinceEpoch;
      await localDataSource.markAsSynced(report.reportId!, now);
      _log.fine('Pushed ${report.reportId} ✓');
    } catch (e, s) {
      _log.warning('Push failed for ${report.reportId}', e, s);
      await localDataSource.markSyncError(
        report.reportId!,
        retries + 1,
        e.toString(),
      );
    }
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Last sync time persistence
  // ─────────────────────────────────────────────────────────────────────────

  Future<int> _getLastSyncTime() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getInt(DbConstants.prefLastSyncTime) ?? 0;
  }

  Future<void> _saveLastSyncTime(int timestamp) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setInt(DbConstants.prefLastSyncTime, timestamp);
    _log.fine('Saved last_sync_time = $timestamp');
  }
}
</file>

<file path="final66133505/lib/core/database/tables.dart">
import '../constants/db_constants.dart';

/// Contains every DDL statement and seed script for the local SQLite database.
///
/// Kept separate from [AppDatabase] so table definitions are easy to review
/// and unit-test in isolation.
class Tables {
  Tables._();

  // ═══════════════════════════════════════════════════════════════════════════
  // CREATE TABLE statements
  // ═══════════════════════════════════════════════════════════════════════════

  /// Master data – pulled from Firestore only.
  static const String createPollingStation =
      '''
    CREATE TABLE ${DbConstants.tablePollingStation} (
      station_id   INTEGER PRIMARY KEY,
      station_name TEXT    NOT NULL,
      zone         TEXT    NOT NULL,
      province     TEXT    NOT NULL,

      updated_at   INTEGER NOT NULL,
      is_deleted   INTEGER DEFAULT 0,
      is_synced    INTEGER DEFAULT 1
    );
  ''';

  /// Master data – pulled from Firestore only.
  static const String createViolationType =
      '''
    CREATE TABLE ${DbConstants.tableViolationType} (
      type_id   INTEGER PRIMARY KEY,
      type_name TEXT    NOT NULL,
      severity  TEXT    NOT NULL,

      updated_at INTEGER NOT NULL,
      is_deleted INTEGER DEFAULT 0,
      is_synced  INTEGER DEFAULT 1
    );
  ''';

  /// Distributed data – full bidirectional sync with conflict resolution.
  static const String createIncidentReport =
      '''
    CREATE TABLE ${DbConstants.tableIncidentReport} (
      report_id      INTEGER PRIMARY KEY AUTOINCREMENT,
      station_id     INTEGER NOT NULL,
      type_id        INTEGER NOT NULL,

      reporter_name  TEXT,
      description    TEXT,
      evidence_photo TEXT,
      timestamp      INTEGER NOT NULL,

      ai_result      TEXT,
      ai_confidence  REAL    DEFAULT 0.0,

      user_id        TEXT    NOT NULL,
      device_id      TEXT    NOT NULL,

      status         TEXT    DEFAULT '${DbConstants.statusPending}',
      is_deleted     INTEGER DEFAULT 0,
      updated_at     INTEGER NOT NULL,
      synced_at      INTEGER,
      retry_count    INTEGER DEFAULT 0,
      last_error     TEXT,

      FOREIGN KEY (station_id) REFERENCES ${DbConstants.tablePollingStation}(station_id),
      FOREIGN KEY (type_id)    REFERENCES ${DbConstants.tableViolationType}(type_id)
    );
  ''';

  // ═══════════════════════════════════════════════════════════════════════════
  // Indices for query performance
  // ═══════════════════════════════════════════════════════════════════════════

  static const String indexReportStation =
      '''
    CREATE INDEX idx_report_station ON ${DbConstants.tableIncidentReport}(station_id);
  ''';

  static const String indexReportType =
      '''
    CREATE INDEX idx_report_type ON ${DbConstants.tableIncidentReport}(type_id);
  ''';

  static const String indexReportTimestamp =
      '''
    CREATE INDEX idx_report_timestamp ON ${DbConstants.tableIncidentReport}(timestamp);
  ''';

  static const String indexReportStatus =
      '''
    CREATE INDEX idx_report_status ON ${DbConstants.tableIncidentReport}(status);
  ''';

  // ═══════════════════════════════════════════════════════════════════════════
  // Seed data (inserted on first install)
  // ═══════════════════════════════════════════════════════════════════════════

  /// All DDL + seed statements to run inside `onCreate`.
  static List<String> get allCreateStatements => [
    createPollingStation,
    createViolationType,
    createIncidentReport,
    indexReportStation,
    indexReportType,
    indexReportTimestamp,
    indexReportStatus,
    ..._seedPollingStations,
    ..._seedViolationTypes,
    ..._seedIncidentReports,
  ];

  // ── polling_station seed ───────────────────────────────────────────────

  static final List<String> _seedPollingStations = [
    _insertStation(101, 'โรงเรียนวัดพระมหาธาตุ', 'เขต 1', 'นครศรีธรรมราช'),
    _insertStation(102, 'เต็นท์หน้าตลาดท่าวัง', 'เขต 1', 'นครศรีธรรมราช'),
    _insertStation(103, 'ศาลากลางหมู่บ้านคีรีวง', 'เขต 2', 'นครศรีธรรมราช'),
    _insertStation(104, 'หอประชุมอำเภอทุ่งสง', 'เขต 3', 'นครศรีธรรมราช'),
  ];

  static String _insertStation(
    int id,
    String name,
    String zone,
    String province,
  ) {
    final now = DateTime.now().millisecondsSinceEpoch;
    return "INSERT INTO ${DbConstants.tablePollingStation} "
        "(station_id, station_name, zone, province, updated_at) "
        "VALUES ($id, '$name', '$zone', '$province', $now);";
  }

  // ── violation_type seed ────────────────────────────────────────────────

  static final List<String> _seedViolationTypes = [
    _insertType(1, 'ซื้อสิทธิ์ขายเสียง (Buying Votes)', 'High'),
    _insertType(2, 'ขนคนไปลงคะแนน (Transportation)', 'High'),
    _insertType(3, 'หาเสียงเกินเวลา (Overtime Campaign)', 'Medium'),
    _insertType(4, 'ทำลายป้ายหาเสียง (Vandalism)', 'Low'),
    _insertType(5, 'เจ้าหน้าที่วางตัวไม่เป็นกลาง (Bias Official)', 'High'),
  ];

  static String _insertType(int id, String name, String severity) {
    final now = DateTime.now().millisecondsSinceEpoch;
    return "INSERT INTO ${DbConstants.tableViolationType} "
        "(type_id, type_name, severity, updated_at) "
        "VALUES ($id, '$name', '$severity', $now);";
  }

  // ── incident_report seed ───────────────────────────────────────────────

  static final List<String> _seedIncidentReports = [
    _insertReport(
      101,
      1,
      'พลเมืองดี 01',
      'พบเห็นการแจกเงินบริเวณหน้าหน่วย',
      null,
      '2026-02-08 09:30:00',
      'Money',
      0.95,
    ),
    _insertReport(
      102,
      3,
      'สมชาย ใจกล้า',
      'มีการเปิดรถแห่เสียงดังรบกวน',
      null,
      '2026-02-08 10:15:00',
      'Crowd',
      0.75,
    ),
    _insertReport(
      103,
      5,
      'Anonymous',
      'เจ้าหน้าที่พูดจาชี้นำผู้ลงคะแนน',
      null,
      '2026-02-08 11:00:00',
      null,
      0.0,
    ),
  ];

  static String _insertReport(
    int stationId,
    int typeId,
    String reporterName,
    String description,
    String? evidencePhoto,
    String timestampStr,
    String? aiResult,
    double aiConfidence,
  ) {
    final ts = DateTime.parse(timestampStr).millisecondsSinceEpoch;
    final now = DateTime.now().millisecondsSinceEpoch;
    final photoVal = evidencePhoto == null ? 'NULL' : "'$evidencePhoto'";
    final aiVal = aiResult == null ? 'NULL' : "'$aiResult'";
    return "INSERT INTO ${DbConstants.tableIncidentReport} "
        "(station_id, type_id, reporter_name, description, "
        "evidence_photo, timestamp, ai_result, ai_confidence, "
        "user_id, device_id, status, updated_at) "
        "VALUES ($stationId, $typeId, '$reporterName', "
        "'$description', $photoVal, $ts, $aiVal, $aiConfidence, "
        "'seed_user', 'seed_device', '${DbConstants.statusPending}', $now);";
  }
}
</file>

<file path="final66133505/lib/core/di/injection.dart">
import 'package:crypto/crypto.dart';
import 'dart:convert';

import 'package:get_it/get_it.dart';
import 'package:logging/logging.dart';

import '../constants/db_constants.dart';
import '../database/app_database.dart';
import '../database/local_datasource.dart';
import '../database/remote_datasource.dart';
import '../database/sync_service.dart';
import '../network/network_info.dart';
import '../services/auto_sync_manager.dart';

/// Global service locator instance.
final sl = GetIt.instance;

final _log = Logger('Injection');

/// Registers every dependency in the correct order.
///
/// Must be called once before `runApp`.
Future<void> configureDependencies() async {
  _log.info('Configuring dependencies…');

  // ── Core infrastructure ──────────────────────────────────────────────
  sl.registerLazySingleton<AppDatabase>(() => AppDatabase.instance);
  sl.registerLazySingleton<NetworkInfo>(() => NetworkInfo());

  // ── Data sources ─────────────────────────────────────────────────────
  sl.registerLazySingleton<LocalDataSource>(
    () => LocalDataSource(appDatabase: sl<AppDatabase>()),
  );
  sl.registerLazySingleton<RemoteDataSource>(() => RemoteDataSource());

  // ── Repositories ─────────────────────────────────────────────────────
  sl.registerLazySingleton<PollingStationRepository>(
    () => PollingStationRepository(
      localDataSource: sl<LocalDataSource>(),
      remoteDataSource: sl<RemoteDataSource>(),
    ),
  );
  sl.registerLazySingleton<ViolationTypeRepository>(
    () => ViolationTypeRepository(
      localDataSource: sl<LocalDataSource>(),
      remoteDataSource: sl<RemoteDataSource>(),
    ),
  );
  sl.registerLazySingleton<IncidentReportRepository>(
    () => IncidentReportRepository(
      localDataSource: sl<LocalDataSource>(),
      remoteDataSource: sl<RemoteDataSource>(),
    ),
  );

  // ── Sync service ─────────────────────────────────────────────────────
  sl.registerLazySingleton<SyncService>(
    () => SyncService(
      localDataSource: sl<LocalDataSource>(),
      remoteDataSource: sl<RemoteDataSource>(),
      networkInfo: sl<NetworkInfo>(),
    ),
  );

  // ── Auto-sync manager ──────────────────────────────────────────────────
  sl.registerLazySingleton<AutoSyncManager>(
    () => AutoSyncManager(
      syncService: sl<SyncService>(),
      networkInfo: sl<NetworkInfo>(),
    ),
  );

  _log.info('Dependencies configured ✓');
}

// ═══════════════════════════════════════════════════════════════════════════════
// Repositories
//
// Each repository sits between the domain / UI layer and the data sources.
// It orchestrates SQLite + Firestore without leaking implementation details.
// ═══════════════════════════════════════════════════════════════════════════════

// ─────────────────────────────────────────────────────────────────────────────
// PollingStationRepository (pull-only master data)
// ─────────────────────────────────────────────────────────────────────────────

class PollingStationRepository {
  PollingStationRepository({
    required this.localDataSource,
    required this.remoteDataSource,
  });

  final LocalDataSource localDataSource;
  final RemoteDataSource remoteDataSource;
  static final _log = Logger('PollingStationRepository');

  /// Returns all non-deleted polling stations from local DB.
  Future<List<PollingStationEntity>> getAll() async {
    return localDataSource.getAllStations();
  }

  /// Returns a single station by ID from local DB.
  Future<PollingStationEntity?> getById(int id) async {
    return localDataSource.getStationById(id);
  }

  /// Creates a new polling station locally AND syncs it to Firestore.
  /// If [stationId] is provided the record will use that exact ID.
  Future<PollingStationEntity> create({
    required String name,
    required String zone,
    required String province,
    int? stationId,
  }) async {
    final now = DateTime.now().millisecondsSinceEpoch;

    int newId;
    if (stationId != null && stationId > 0) {
      // Caller supplied an explicit ID — upsert so it is preserved.
      final entity = PollingStationEntity(
        stationId: stationId,
        stationName: name.trim(),
        zone: zone.trim(),
        province: province.trim(),
        updatedAt: now,
        isSynced: false,
      );
      await localDataSource.upsertStation(entity);
      newId = stationId;
    } else {
      // Auto-assign ID via SQLite autoincrement.
      final tmp = PollingStationEntity(
        stationId: 0,
        stationName: name.trim(),
        zone: zone.trim(),
        province: province.trim(),
        updatedAt: now,
        isSynced: false,
      );
      newId = await localDataSource.insertNewStation(tmp);
    }

    final created = PollingStationEntity(
      stationId: newId,
      stationName: name.trim(),
      zone: zone.trim(),
      province: province.trim(),
      updatedAt: now,
      isSynced: true,
    );
    _log.info('Created station id=$newId name=${name.trim()}');

    // Push to Firestore immediately (best-effort)
    try {
      await remoteDataSource.pushStations([created]);
      _log.info('Station id=$newId synced to Firestore');
    } catch (e) {
      _log.warning('Station id=$newId Firestore sync failed (will retry): $e');
      // Mark as unsynced so AutoSyncManager picks it up later
      await localDataSource.upsertStation(
        PollingStationEntity(
          stationId: newId,
          stationName: created.stationName,
          zone: created.zone,
          province: created.province,
          updatedAt: now,
          isSynced: false,
        ),
      );
    }
    return created;
  }

  /// Pulls all polling stations from Firestore → SQLite.
  Future<void> pullFromFirestore() async {
    try {
      final remote = await remoteDataSource.fetchAllStations();
      if (remote.isNotEmpty) {
        await localDataSource.upsertStations(remote);
        _log.info('pullFromFirestore → ${remote.length} stations');
      }
    } catch (e, s) {
      _log.warning('pullFromFirestore failed', e, s);
    }
  }

  /// Pushes all local stations to Firestore (initial seed).
  Future<void> pushAllToFirestore() async {
    try {
      final local = await localDataSource.getAllStations();
      if (local.isNotEmpty) {
        await remoteDataSource.pushStations(local);
        _log.info('pushAllToFirestore → ${local.length} stations');
      }
    } catch (e, s) {
      _log.warning('pushAllToFirestore failed', e, s);
    }
  }
}

// ─────────────────────────────────────────────────────────────────────────────
// ViolationTypeRepository (pull-only master data)
// ─────────────────────────────────────────────────────────────────────────────

class ViolationTypeRepository {
  ViolationTypeRepository({
    required this.localDataSource,
    required this.remoteDataSource,
  });

  final LocalDataSource localDataSource;
  final RemoteDataSource remoteDataSource;
  static final _log = Logger('ViolationTypeRepository');

  /// Returns all non-deleted violation types from local DB.
  Future<List<ViolationTypeEntity>> getAll() async {
    return localDataSource.getAllTypes();
  }

  /// Returns a single type by ID from local DB.
  Future<ViolationTypeEntity?> getById(int id) async {
    return localDataSource.getTypeById(id);
  }

  /// Creates a new violation type locally AND syncs it to Firestore.
  Future<ViolationTypeEntity> create({
    required String name,
    required String severity,
  }) async {
    final now = DateTime.now().millisecondsSinceEpoch;
    final tmp = ViolationTypeEntity(
      typeId: 0,
      typeName: name.trim(),
      severity: severity,
      updatedAt: now,
      isSynced: false,
    );
    final newId = await localDataSource.insertNewType(tmp);
    final created = ViolationTypeEntity(
      typeId: newId,
      typeName: tmp.typeName,
      severity: tmp.severity,
      updatedAt: now,
      isSynced: true,
    );
    _log.info('Created type id=$newId name=${tmp.typeName}');

    // Push to Firestore immediately (best-effort)
    try {
      await remoteDataSource.pushTypes([created]);
      _log.info('Type id=$newId synced to Firestore');
    } catch (e) {
      _log.warning('Type id=$newId Firestore sync failed (will retry): $e');
    }
    return created;
  }

  /// Pulls all violation types from Firestore → SQLite.
  Future<void> pullFromFirestore() async {
    try {
      final remote = await remoteDataSource.fetchAllTypes();
      if (remote.isNotEmpty) {
        await localDataSource.upsertTypes(remote);
        _log.info('pullFromFirestore → ${remote.length} types');
      }
    } catch (e, s) {
      _log.warning('pullFromFirestore failed', e, s);
    }
  }

  /// Pushes all local types to Firestore (initial seed).
  Future<void> pushAllToFirestore() async {
    try {
      final local = await localDataSource.getAllTypes();
      if (local.isNotEmpty) {
        await remoteDataSource.pushTypes(local);
        _log.info('pushAllToFirestore → ${local.length} types');
      }
    } catch (e, s) {
      _log.warning('pushAllToFirestore failed', e, s);
    }
  }
}

// ─────────────────────────────────────────────────────────────────────────────
// IncidentReportRepository (bidirectional sync)
// ─────────────────────────────────────────────────────────────────────────────

class IncidentReportRepository {
  IncidentReportRepository({
    required this.localDataSource,
    required this.remoteDataSource,
  });

  final LocalDataSource localDataSource;
  final RemoteDataSource remoteDataSource;
  static final _log = Logger('IncidentReportRepository');

  /// Returns all non-deleted reports from local DB.
  Future<List<IncidentReportEntity>> getAll() async {
    return localDataSource.getAllReports();
  }

  /// Returns a single report by its integer ID.
  Future<IncidentReportEntity?> getById(int id) async {
    return localDataSource.getReportById(id);
  }

  /// Creates a new incident report. SQLite auto-assigns the report_id.
  Future<void> create(IncidentReportEntity entity) async {
    final now = DateTime.now().millisecondsSinceEpoch;
    final deviceId = _generateDeviceId();

    final report = entity.copyWith(
      updatedAt: now,
      status: DbConstants.statusPending,
      userId: entity.userId.isEmpty ? 'anonymous' : null,
      deviceId: entity.deviceId.isEmpty ? deviceId : null,
    );

    final newId = await localDataSource.insertReport(report);
    _log.info('Created report id=$newId');
  }

  /// Deletes a report from both SQLite and Firestore.
  Future<void> delete(int id) async {
    // 1. Remove from SQLite immediately (hard delete)
    await localDataSource.hardDeleteReport(id);
    _log.info('Hard-deleted report $id from SQLite');

    // 2. Best-effort remove from Firestore
    try {
      await remoteDataSource.deleteRemoteReport(id);
      _log.info('Deleted report $id from Firestore');
    } catch (e) {
      // Not fatal — Firestore delete will be retried via sync
      _log.warning('Could not delete report $id from Firestore: $e');
    }
  }

  /// Updates an existing report, marking it pending sync again.
  Future<void> update(IncidentReportEntity entity) async {
    final now = DateTime.now().millisecondsSinceEpoch;
    final updated = entity.copyWith(
      updatedAt: now,
      status: DbConstants.statusPending,
    );
    await localDataSource.updateReport(updated);
    _log.info('Updated report id=${entity.reportId}');
  }

  /// Returns the count of reports not yet synced.
  Future<int> getUnsyncedCount() async {
    return localDataSource.getUnsyncedReportCount();
  }

  /// Pushes all unsynced reports to Firestore.
  Future<void> syncUnsynced() async {
    try {
      final pending = await localDataSource.getPendingReports();
      if (pending.isNotEmpty) {
        await remoteDataSource.uploadReports(pending);
        final now = DateTime.now().millisecondsSinceEpoch;
        for (final r in pending) {
          if (r.reportId != null) {
            await localDataSource.markAsSynced(r.reportId!, now);
          }
        }
        _log.info('syncUnsynced → ${pending.length} reports pushed');
      }
    } catch (e, s) {
      _log.warning('syncUnsynced failed', e, s);
    }
  }

  /// Pushes ALL local reports (regardless of sync status) to Firestore.
  ///
  /// Used for the initial seed push so that even `synced`-marked seed rows
  /// are uploaded on first run.
  Future<void> pushAllToFirestore() async {
    try {
      final all = await localDataSource.getAllReports();
      if (all.isEmpty) return;
      await remoteDataSource.uploadReports(all);
      final now = DateTime.now().millisecondsSinceEpoch;
      for (final r in all) {
        if (r.reportId != null) {
          await localDataSource.markAsSynced(r.reportId!, now);
        }
      }
      _log.info('pushAllToFirestore → ${all.length} reports pushed');
    } catch (e, s) {
      _log.warning('pushAllToFirestore failed', e, s);
    }
  }

  /// Pulls all reports from Firestore and merges into SQLite.
  Future<void> pullFromFirestore() async {
    try {
      final remote = await remoteDataSource.fetchAllReports();
      for (final r in remote) {
        if (r.reportId == null) continue;

        // Use raw getReportById that ignores is_deleted so we don't
        // attempt a duplicate INSERT on soft-deleted rows.
        final local = await localDataSource.getReportByIdAny(r.reportId!);
        final synced = r.copyWith(
          status: DbConstants.statusSynced,
          syncedAt: DateTime.now().millisecondsSinceEpoch,
        );

        if (local == null) {
          // Truly new — safe to insert
          await localDataSource.insertReport(synced);
        } else if (r.updatedAt > local.updatedAt) {
          // Remote is newer (or local was soft-deleted) — overwrite
          await localDataSource.updateReport(synced);
        }
        // else: local is up-to-date, skip
      }
      _log.info('pullFromFirestore → ${remote.length} reports processed');
    } catch (e, s) {
      _log.warning('pullFromFirestore failed', e, s);
    }
  }

  /// Generates a deterministic device ID for this install.
  static String _generateDeviceId() {
    final hash = sha256
        .convert(utf8.encode('election_monitor_device'))
        .toString();
    return hash.substring(0, 16);
  }
}
</file>

<file path="final66133505/lib/core/network/network_info.dart">
import 'dart:async';

import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:logging/logging.dart';

/// Provides a reactive and imperative API for checking network connectivity.
///
/// Wraps [Connectivity] so the rest of the app depends on an abstraction
/// rather than a concrete plugin — making it easy to mock in tests.
class NetworkInfo {
  NetworkInfo({Connectivity? connectivity})
      : _connectivity = connectivity ?? Connectivity();

  final Connectivity _connectivity;
  static final _log = Logger('NetworkInfo');

  /// Returns `true` if the device currently has internet access
  /// (Wi-Fi, mobile data, ethernet, etc.).
  Future<bool> get isConnected async {
    final results = await _connectivity.checkConnectivity();
    final connected = !results.contains(ConnectivityResult.none);
    _log.fine('isConnected: $connected ($results)');
    return connected;
  }

  /// Emits whenever connectivity state changes.
  ///
  /// Useful for triggering automatic sync when the device comes back online.
  Stream<bool> get onConnectivityChanged {
    return _connectivity.onConnectivityChanged.map((results) {
      final connected = !results.contains(ConnectivityResult.none);
      _log.fine('Connectivity changed → connected: $connected');
      return connected;
    });
  }
}
</file>

<file path="final66133505/lib/core/services/auto_sync_manager.dart">
import 'dart:async';

import 'package:flutter/widgets.dart';
import 'package:logging/logging.dart';

import '../database/sync_service.dart';
import '../di/injection.dart';
import '../network/network_info.dart';

// ═════════════════════════════════════════════════════════════════════════════
// Sync status model
// ═════════════════════════════════════════════════════════════════════════════

enum SyncState { idle, syncing, synced, offline, error }

class SyncStatus {
  final SyncState state;
  final int pendingCount;
  final String? errorMessage;
  final DateTime? lastSyncTime;

  const SyncStatus({
    this.state = SyncState.idle,
    this.pendingCount = 0,
    this.errorMessage,
    this.lastSyncTime,
  });

  SyncStatus copyWith({
    SyncState? state,
    int? pendingCount,
    String? errorMessage,
    DateTime? lastSyncTime,
  }) {
    return SyncStatus(
      state: state ?? this.state,
      pendingCount: pendingCount ?? this.pendingCount,
      errorMessage: errorMessage,
      lastSyncTime: lastSyncTime ?? this.lastSyncTime,
    );
  }

  bool get isSyncing => state == SyncState.syncing;
  bool get isOffline => state == SyncState.offline;
  bool get hasPending => pendingCount > 0;
}

// ═════════════════════════════════════════════════════════════════════════════
// AutoSyncManager — production-grade background sync orchestrator
// ═════════════════════════════════════════════════════════════════════════════

/// Manages automatic background synchronization with:
///   • Periodic sync every [syncInterval]
///   • Connectivity-aware sync (auto-syncs when back online)
///   • App lifecycle-aware (syncs on resume, pauses on background)
///   • Stream-based status broadcasting for reactive UI
///   • Debounce protection to prevent overlapping syncs
class AutoSyncManager with WidgetsBindingObserver {
  AutoSyncManager({
    required SyncService syncService,
    required NetworkInfo networkInfo,
    this.syncInterval = const Duration(seconds: 30),
  }) : _syncService = syncService,
       _networkInfo = networkInfo;

  final SyncService _syncService;
  final NetworkInfo _networkInfo;
  final Duration syncInterval;

  static final _log = Logger('AutoSyncManager');

  // ── State ────────────────────────────────────────────────────────────────
  final _statusController = StreamController<SyncStatus>.broadcast();
  SyncStatus _currentStatus = const SyncStatus();
  bool _isSyncing = false;
  bool _isInitialized = false;

  Timer? _periodicTimer;
  StreamSubscription<bool>? _connectivitySub;

  /// Reactive stream of sync status changes.
  Stream<SyncStatus> get statusStream => _statusController.stream;

  /// Current sync status snapshot.
  SyncStatus get currentStatus => _currentStatus;

  // ── Lifecycle ────────────────────────────────────────────────────────────

  /// Call once at app startup after DI is configured.
  Future<void> initialize() async {
    if (_isInitialized) return;
    _isInitialized = true;

    _log.info('AutoSyncManager initializing…');

    // Register as lifecycle observer.
    WidgetsBinding.instance.addObserver(this);

    // Check initial connectivity and set status.
    final online = await _networkInfo.isConnected;
    if (!online) {
      _emit(_currentStatus.copyWith(state: SyncState.offline));
    }

    // Listen to connectivity changes.
    _connectivitySub = _networkInfo.onConnectivityChanged.listen((online) {
      if (online) {
        _log.info('Back online → triggering sync');
        _emit(_currentStatus.copyWith(state: SyncState.idle));
        requestSync();
      } else {
        _log.info('Gone offline');
        _emit(_currentStatus.copyWith(state: SyncState.offline));
      }
    });

    // Start periodic timer.
    _startPeriodicSync();

    // Initial sync.
    await requestSync();

    _log.info('AutoSyncManager initialized ✓');
  }

  /// Tear down all timers, subscriptions, and observers.
  void dispose() {
    _periodicTimer?.cancel();
    _connectivitySub?.cancel();
    WidgetsBinding.instance.removeObserver(this);
    _statusController.close();
    _isInitialized = false;
    _log.info('AutoSyncManager disposed');
  }

  // ── App lifecycle ────────────────────────────────────────────────────────

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    switch (state) {
      case AppLifecycleState.resumed:
        _log.fine('App resumed → restarting periodic sync');
        _startPeriodicSync();
        requestSync();
        break;
      case AppLifecycleState.paused:
      case AppLifecycleState.inactive:
        _log.fine('App paused → stopping periodic sync');
        _periodicTimer?.cancel();
        break;
      default:
        break;
    }
  }

  // ── Sync control ─────────────────────────────────────────────────────────

  /// Request a sync. Safe to call multiple times — concurrent syncs are
  /// debounced automatically.
  Future<void> requestSync() async {
    if (_isSyncing) {
      _log.fine('Sync already in progress — skipping');
      return;
    }

    final online = await _networkInfo.isConnected;
    if (!online) {
      // Update pending count even when offline.
      await _refreshPendingCount();
      _emit(_currentStatus.copyWith(state: SyncState.offline));
      return;
    }

    _isSyncing = true;
    _emit(_currentStatus.copyWith(state: SyncState.syncing));

    try {
      await _syncService.syncAll();
      await _refreshPendingCount();
      _emit(
        _currentStatus.copyWith(
          state: SyncState.synced,
          lastSyncTime: DateTime.now(),
          errorMessage: null,
        ),
      );
      _log.fine('Background sync completed ✓');

      // Revert to idle after a short display delay.
      Future.delayed(const Duration(seconds: 3), () {
        if (_currentStatus.state == SyncState.synced) {
          _emit(_currentStatus.copyWith(state: SyncState.idle));
        }
      });
    } catch (e, s) {
      _log.warning('Background sync failed', e, s);
      await _refreshPendingCount();
      _emit(
        _currentStatus.copyWith(
          state: SyncState.error,
          errorMessage: e.toString(),
        ),
      );

      // Revert to idle after showing error.
      Future.delayed(const Duration(seconds: 5), () {
        if (_currentStatus.state == SyncState.error) {
          _emit(_currentStatus.copyWith(state: SyncState.idle));
        }
      });
    } finally {
      _isSyncing = false;
    }
  }

  // ── Internals ────────────────────────────────────────────────────────────

  void _startPeriodicSync() {
    _periodicTimer?.cancel();
    _periodicTimer = Timer.periodic(syncInterval, (_) => requestSync());
  }

  Future<void> _refreshPendingCount() async {
    try {
      final repo = sl<IncidentReportRepository>();
      final count = await repo.getUnsyncedCount();
      _currentStatus = _currentStatus.copyWith(pendingCount: count);
    } catch (_) {}
  }

  void _emit(SyncStatus status) {
    _currentStatus = status;
    if (!_statusController.isClosed) {
      _statusController.add(status);
    }
  }
}
</file>

<file path="final66133505/lib/core/theme/app_theme.dart">
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

/// Election-themed application theme.
///
/// Colors inspired by Thai election / civic duty aesthetics:
///   • Primary: deep navy-blue (trustworthy, official)
///   • Secondary: warm gold (authority, national pride)
///   • Tertiary: crimson-red (urgency, alerts)
///   • Surface variants: clean neutrals for readability
abstract final class AppTheme {
  // ─── Color Palette ──────────────────────────────────────────────────────

  static const _primarySeed = Color(0xFF0D47A1); // deep navy
  static const _gold = Color(0xFFD4A017); // Thai gold
  static const _crimson = Color(0xFFC62828); // alert red
  static const _teal = Color(0xFF00796B); // success / synced

  // ─── Color Scheme ───────────────────────────────────────────────────────

  static final ColorScheme _lightScheme = ColorScheme.fromSeed(
    seedColor: _primarySeed,
    brightness: Brightness.light,
    primary: const Color(0xFF0D47A1),
    onPrimary: Colors.white,
    primaryContainer: const Color(0xFFD6E4FF),
    onPrimaryContainer: const Color(0xFF001B3F),
    secondary: _gold,
    onSecondary: Colors.white,
    secondaryContainer: const Color(0xFFFFF1CC),
    onSecondaryContainer: const Color(0xFF3E2E00),
    tertiary: _crimson,
    onTertiary: Colors.white,
    tertiaryContainer: const Color(0xFFFFDAD6),
    onTertiaryContainer: const Color(0xFF410002),
    error: const Color(0xFFBA1A1A),
    surface: const Color(0xFFF8F9FC),
    onSurface: const Color(0xFF1A1C1E),
    onSurfaceVariant: const Color(0xFF44474E),
    outline: const Color(0xFF74777F),
    outlineVariant: const Color(0xFFC4C6D0),
    surfaceContainerHighest: const Color(0xFFE2E2E6),
  );

  // ─── Severity Colors (used across the app) ─────────────────────────────

  static const Color severityHigh = Color(0xFFD32F2F);
  static const Color severityMedium = Color(0xFFEF6C00);
  static const Color severityLow = Color(0xFF2E7D32);

  static Color severityColor(String severity) {
    switch (severity.toLowerCase()) {
      case 'high':
        return severityHigh;
      case 'medium':
        return severityMedium;
      case 'low':
        return severityLow;
      default:
        return Colors.grey;
    }
  }

  static const Color syncedColor = _teal;
  static const Color pendingColor = Color(0xFFE65100);
  static const Color offlineColor = Color(0xFF616161);

  // ─── Chart Colors ───────────────────────────────────────────────────────

  static const List<Color> chartColors = [
    Color(0xFF0D47A1), // navy
    Color(0xFFD4A017), // gold
    Color(0xFFC62828), // crimson
    Color(0xFF00796B), // teal
    Color(0xFF6A1B9A), // purple
    Color(0xFFEF6C00), // amber
    Color(0xFF1565C0), // blue
    Color(0xFF2E7D32), // green
  ];

  // ─── Theme Data ─────────────────────────────────────────────────────────

  static ThemeData get light {
    final textTheme = GoogleFonts.promptTextTheme(ThemeData.light().textTheme);

    return ThemeData(
      useMaterial3: true,
      colorScheme: _lightScheme,
      brightness: Brightness.light,
      textTheme: textTheme,

      // ── AppBar ───────────────────────────────────────────────────
      appBarTheme: AppBarTheme(
        centerTitle: false,
        elevation: 0,
        scrolledUnderElevation: 2,
        backgroundColor: _lightScheme.surface,
        foregroundColor: _lightScheme.onSurface,
        titleTextStyle: GoogleFonts.prompt(
          fontSize: 20,
          fontWeight: FontWeight.w700,
          color: _lightScheme.onSurface,
        ),
      ),

      // ── Card ─────────────────────────────────────────────────────
      cardTheme: CardThemeData(
        elevation: 0,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
          side: BorderSide(color: _lightScheme.outlineVariant.withOpacity(0.5)),
        ),
        color: Colors.white,
        surfaceTintColor: Colors.transparent,
      ),

      // ── Input Decoration ─────────────────────────────────────────
      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: _lightScheme.surfaceContainerHighest.withOpacity(0.3),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide.none,
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: _lightScheme.primary, width: 2),
        ),
        contentPadding: const EdgeInsets.symmetric(
          horizontal: 16,
          vertical: 14,
        ),
      ),

      // ── Filled Button ────────────────────────────────────────────
      filledButtonTheme: FilledButtonThemeData(
        style: FilledButton.styleFrom(
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 14),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
          textStyle: GoogleFonts.prompt(
            fontWeight: FontWeight.w600,
            fontSize: 14,
          ),
        ),
      ),

      // ── Elevated Button ──────────────────────────────────────────
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 14),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
          textStyle: GoogleFonts.prompt(
            fontWeight: FontWeight.w600,
            fontSize: 14,
          ),
        ),
      ),

      // ── Navigation Bar ───────────────────────────────────────────
      navigationBarTheme: NavigationBarThemeData(
        elevation: 2,
        height: 72,
        indicatorColor: _lightScheme.primaryContainer,
        backgroundColor: Colors.white,
        surfaceTintColor: Colors.transparent,
        labelTextStyle: WidgetStateProperty.resolveWith((states) {
          if (states.contains(WidgetState.selected)) {
            return GoogleFonts.prompt(
              fontSize: 12,
              fontWeight: FontWeight.w600,
              color: _lightScheme.primary,
            );
          }
          return GoogleFonts.prompt(
            fontSize: 12,
            fontWeight: FontWeight.w500,
            color: _lightScheme.onSurfaceVariant,
          );
        }),
      ),

      // ── FAB ──────────────────────────────────────────────────────
      floatingActionButtonTheme: FloatingActionButtonThemeData(
        backgroundColor: _lightScheme.primary,
        foregroundColor: _lightScheme.onPrimary,
        elevation: 4,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      ),

      // ── Snackbar ─────────────────────────────────────────────────
      snackBarTheme: SnackBarThemeData(
        behavior: SnackBarBehavior.floating,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      ),

      // ── Dialog ───────────────────────────────────────────────────
      dialogTheme: DialogThemeData(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
      ),

      // ── Chip ─────────────────────────────────────────────────────
      chipTheme: ChipThemeData(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
      ),
    );
  }
}
</file>

<file path="final66133505/lib/core/utils/image_storage.dart">
import 'dart:io';

import 'package:logging/logging.dart';
import 'package:path/path.dart' as p;
import 'package:path_provider/path_provider.dart';

/// Utility for persisting picked images to the app's temporary directory.
///
/// `getTemporaryDirectory()` returns a persistent-enough cache dir that:
///   • survives across sessions on Android/iOS
///   • is accessible without extra permissions
///   • gets cleared by the OS only when storage is critically low
abstract final class ImageStorage {
  static final _log = Logger('ImageStorage');

  /// Copies [sourcePath] into `<tmpDir>/evidence_images/<fileName>`
  /// and returns the new persistent path.
  ///
  /// Returns [sourcePath] unchanged if copy fails.
  static Future<String> copyToTemp(String sourcePath) async {
    try {
      final tmpDir = await getTemporaryDirectory();
      final destDir = Directory(p.join(tmpDir.path, 'evidence_images'));
      if (!destDir.existsSync()) {
        destDir.createSync(recursive: true);
      }

      final ext = p.extension(sourcePath).isNotEmpty
          ? p.extension(sourcePath)
          : '.jpg';
      final fileName = 'evidence_${DateTime.now().millisecondsSinceEpoch}$ext';
      final destPath = p.join(destDir.path, fileName);

      await File(sourcePath).copy(destPath);
      _log.info('Image saved to temp: $destPath');
      return destPath;
    } catch (e, s) {
      _log.severe('Failed to copy image to temp dir', e, s);
      return sourcePath; // fallback to original path
    }
  }

  /// Returns true if the file at [path] exists and is readable.
  static bool exists(String? path) {
    if (path == null || path.isEmpty) return false;
    return File(path).existsSync();
  }
}
</file>

<file path="final66133505/lib/core/utils/tflite_classifier.dart">
import 'dart:io';
import 'package:flutter/services.dart';
import 'package:image/image.dart' as img;
import 'package:logging/logging.dart';
import 'package:tflite_flutter/tflite_flutter.dart';

/// Result from a TFLite classification.
class ClassificationResult {
  final String label;
  final double confidence;
  final String severity;

  const ClassificationResult({
    required this.label,
    required this.confidence,
    required this.severity,
  });
}

/// Wraps a TFLite image-classification model.
///
/// **Model contract**
/// - File  : `assets/models/incident_classifier.tflite`
/// - Labels: `assets/models/incident_labels.txt`  (one label per line)
/// - Input : `[1, 224, 224, 3]` FLOAT32, normalised to [0, 1]
/// - Output: `[1, N]` FLOAT32  (one probability per class)
///
/// The label file maps each index → human-readable class name.
/// A `severity_map.txt` (optional) maps each class name → High / Medium / Low.
/// If the severity map is absent every class defaults to 'Medium'.
class TFLiteClassifier {
  static final _log = Logger('TFLiteClassifier');

  static const _modelPath = 'assets/models/incident_classifier.tflite';
  static const _labelsPath = 'assets/models/incident_labels.txt';
  static const _severityMapPath = 'assets/models/severity_map.txt';

  static const int _inputSize = 224; // expected width & height

  Interpreter? _interpreter;
  List<String> _labels = [];
  Map<String, String> _severityMap = {};

  bool get isReady => _interpreter != null && _labels.isNotEmpty;

  // ── Initialise ────────────────────────────────────────────────────────────

  /// Load model + labels from assets.  Safe to call multiple times (no-op if
  /// already loaded).
  Future<void> init() async {
    if (isReady) return;
    try {
      _interpreter = await Interpreter.fromAsset(_modelPath);
      _labels = await _loadLines(_labelsPath);
      _severityMap = await _loadSeverityMap();
      _log.info(
        'TFLiteClassifier ready — ${_labels.length} classes, '
        'input ${_interpreter!.getInputTensor(0).shape}',
      );
    } catch (e, s) {
      _log.severe('Failed to load TFLite model', e, s);
      _interpreter = null;
      rethrow;
    }
  }

  /// Release interpreter resources.
  void close() {
    _interpreter?.close();
    _interpreter = null;
  }

  // ── Classify ──────────────────────────────────────────────────────────────

  /// Run inference on [imageFile].
  ///
  /// Returns `null` if the model is not loaded or preprocessing fails.
  Future<ClassificationResult?> classify(File imageFile) async {
    if (!isReady) {
      _log.warning('classify() called before init()');
      return null;
    }

    try {
      final input = await _preprocess(imageFile);
      if (input == null) return null;

      final outputShape =
          _interpreter!.getOutputTensor(0).shape; // [1, numClasses]
      final numClasses = outputShape.last;
      final outputBuffer =
          List.generate(1, (_) => List<double>.filled(numClasses, 0.0));

      _interpreter!.run(input, outputBuffer);

      final probs = outputBuffer[0];
      final maxIdx = _argMax(probs);
      final confidence = probs[maxIdx];
      final label =
          maxIdx < _labels.length ? _labels[maxIdx] : 'Unknown ($maxIdx)';
      final severity = _severityMap[label] ?? _defaultSeverity(confidence);

      _log.fine('Result: $label  conf=${confidence.toStringAsFixed(3)}');

      return ClassificationResult(
        label: label,
        confidence: confidence,
        severity: severity,
      );
    } catch (e, s) {
      _log.severe('Inference failed', e, s);
      return null;
    }
  }

  // ── Preprocessing ─────────────────────────────────────────────────────────

  /// Decode → resize to [_inputSize]² → normalise → return [1,H,W,3] Float32.
  Future<List<List<List<List<double>>>>?> _preprocess(File imageFile) async {
    try {
      final bytes = await imageFile.readAsBytes();
      img.Image? decoded = img.decodeImage(bytes);
      if (decoded == null) {
        _log.warning('Could not decode image: ${imageFile.path}');
        return null;
      }

      // Resize
      final resized = img.copyResize(
        decoded,
        width: _inputSize,
        height: _inputSize,
        interpolation: img.Interpolation.linear,
      );

      // Build [1, H, W, 3] Float32 normalised to [0, 1]
      return List.generate(1, (_) {
        return List.generate(_inputSize, (y) {
          return List.generate(_inputSize, (x) {
            final pixel = resized.getPixel(x, y);
            return [
              pixel.r / 255.0,
              pixel.g / 255.0,
              pixel.b / 255.0,
            ];
          });
        });
      });
    } catch (e, s) {
      _log.severe('Preprocessing failed', e, s);
      return null;
    }
  }

  // ── Helpers ───────────────────────────────────────────────────────────────

  Future<List<String>> _loadLines(String assetPath) async {
    try {
      final raw = await rootBundle.loadString(assetPath);
      return raw
          .split('\n')
          .map((l) => l.trim())
          .where((l) => l.isNotEmpty)
          .toList();
    } catch (e) {
      _log.warning('Could not load $assetPath: $e');
      return [];
    }
  }

  /// Parses `severity_map.txt` — lines like `Ballot Stuffing:High`.
  Future<Map<String, String>> _loadSeverityMap() async {
    final map = <String, String>{};
    try {
      final lines = await _loadLines(_severityMapPath);
      for (final line in lines) {
        final parts = line.split(':');
        if (parts.length == 2) {
          map[parts[0].trim()] = parts[1].trim();
        }
      }
    } catch (_) {
      // Optional file — silently ignore
    }
    return map;
  }

  int _argMax(List<double> values) {
    int maxIdx = 0;
    double maxVal = values[0];
    for (int i = 1; i < values.length; i++) {
      if (values[i] > maxVal) {
        maxVal = values[i];
        maxIdx = i;
      }
    }
    return maxIdx;
  }

  /// Fallback severity when no `severity_map.txt` entry is found.
  String _defaultSeverity(double confidence) {
    if (confidence >= 0.75) return 'High';
    if (confidence >= 0.45) return 'Medium';
    return 'Low';
  }
}

/// Global singleton — shared across all pages so the model is loaded once.
final tfliteClassifier = TFLiteClassifier();
</file>

<file path="final66133505/lib/features/analysis/presentation/page/ai_scanner.dart">
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:image_picker/image_picker.dart';
import 'package:logging/logging.dart';

import 'package:final66133505/core/theme/app_theme.dart';
import 'package:final66133505/core/utils/image_storage.dart';
import 'package:final66133505/core/utils/tflite_classifier.dart';

/// AI-powered election incident scanner page.
class AiScanner extends StatefulWidget {
  const AiScanner({super.key});

  @override
  State<AiScanner> createState() => _AiScannerState();
}

class _AiScannerState extends State<AiScanner>
    with SingleTickerProviderStateMixin {
  static final _log = Logger('AiScanner');

  final ImagePicker _picker = ImagePicker();

  XFile? _pickedImage;
  bool _isAnalyzing = false;
  String? _prediction;
  double _confidence = 0.0;
  String? _severity;

  late final AnimationController _pulseCtrl;
  late final Animation<double> _pulseAnim;

  @override
  void initState() {
    super.initState();
    _pulseCtrl = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1400),
    )..repeat(reverse: true);
    _pulseAnim = Tween<double>(
      begin: 0.92,
      end: 1.0,
    ).animate(CurvedAnimation(parent: _pulseCtrl, curve: Curves.easeInOut));
  }

  @override
  void dispose() {
    _pulseCtrl.dispose();
    super.dispose();
  }

  Future<void> _pickImage(ImageSource source) async {
    try {
      final image = await _picker.pickImage(
        source: source,
        maxWidth: 1024,
        maxHeight: 1024,
        imageQuality: 85,
      );
      if (image != null) {
        // Copy to persistent temp dir so the path survives process restarts.
        final persistentPath = await ImageStorage.copyToTemp(image.path);
        setState(() {
          _pickedImage = XFile(persistentPath);
          _prediction = null;
          _confidence = 0.0;
          _severity = null;
        });
      }
    } catch (e) {
      _log.warning('Image pick failed: \$e');
      if (mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text('Failed to pick image: \$e')));
      }
    }
  }

  void _showImageSourceSheet() {
    final cs = Theme.of(context).colorScheme;
    showModalBottomSheet(
      context: context,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
      ),
      builder: (ctx) => SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(vertical: 20),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Container(
                width: 40,
                height: 4,
                decoration: BoxDecoration(
                  color: Colors.grey.shade300,
                  borderRadius: BorderRadius.circular(2),
                ),
              ),
              const SizedBox(height: 20),
              Text(
                'Select Image Source',
                style: GoogleFonts.prompt(
                  fontSize: 16,
                  fontWeight: FontWeight.w700,
                ),
              ),
              const SizedBox(height: 16),
              ListTile(
                leading: CircleAvatar(
                  backgroundColor: cs.primaryContainer,
                  child: Icon(Icons.camera_alt_rounded, color: cs.primary),
                ),
                title: Text('Camera', style: GoogleFonts.prompt()),
                subtitle: Text(
                  'Take a new photo',
                  style: GoogleFonts.prompt(fontSize: 12),
                ),
                onTap: () {
                  Navigator.pop(ctx);
                  _pickImage(ImageSource.camera);
                },
              ),
              ListTile(
                leading: CircleAvatar(
                  backgroundColor: cs.secondaryContainer,
                  child: Icon(Icons.photo_library_rounded, color: cs.secondary),
                ),
                title: Text('Gallery', style: GoogleFonts.prompt()),
                subtitle: Text(
                  'Choose from gallery',
                  style: GoogleFonts.prompt(fontSize: 12),
                ),
                onTap: () {
                  Navigator.pop(ctx);
                  _pickImage(ImageSource.gallery);
                },
              ),
            ],
          ),
        ),
      ),
    );
  }

  Future<void> _analyzeImage() async {
    if (_pickedImage == null) return;
    setState(() => _isAnalyzing = true);

    try {
      // Ensure the model is loaded (no-op if already initialised)
      await tfliteClassifier.init();

      final result = await tfliteClassifier.classify(File(_pickedImage!.path));

      if (result != null) {
        setState(() {
          _prediction = result.label;
          _confidence = result.confidence;
          _severity = result.severity;
        });
      } else {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Analysis failed — try another image')),
          );
        }
      }
    } catch (e) {
      _log.warning('AI analysis error: $e');
      if (mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text('AI error: $e')));
      }
    } finally {
      if (mounted) setState(() => _isAnalyzing = false);
    }
  }

  void _reset() {
    setState(() {
      _pickedImage = null;
      _prediction = null;
      _confidence = 0.0;
      _severity = null;
    });
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final cs = theme.colorScheme;

    return SingleChildScrollView(
      padding: const EdgeInsets.fromLTRB(20, 16, 20, 32),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          _buildHeader(cs),
          const SizedBox(height: 24),
          _buildImageArea(theme, cs),
          const SizedBox(height: 20),
          _buildActions(cs),
          if (_prediction != null) ...[
            const SizedBox(height: 24),
            _buildResult(theme, cs),
          ],
          if (_pickedImage == null && _prediction == null) ...[
            const SizedBox(height: 32),
            _buildHowItWorks(theme, cs),
          ],
        ],
      ),
    );
  }

  Widget _buildHeader(ColorScheme cs) {
    return Row(
      children: [
        Container(
          padding: const EdgeInsets.all(10),
          decoration: BoxDecoration(
            gradient: const LinearGradient(
              colors: [Color(0xFF0D47A1), Color(0xFF1976D2)],
            ),
            borderRadius: BorderRadius.circular(14),
          ),
          child: const Icon(
            Icons.document_scanner_rounded,
            size: 26,
            color: Colors.white,
          ),
        ),
        const SizedBox(width: 14),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'AI Scanner',
                style: GoogleFonts.prompt(
                  fontSize: 22,
                  fontWeight: FontWeight.w800,
                  color: cs.onSurface,
                ),
              ),
              Text(
                'Analyze election evidence photos',
                style: GoogleFonts.prompt(
                  fontSize: 13,
                  color: cs.onSurfaceVariant,
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildImageArea(ThemeData theme, ColorScheme cs) {
    if (_pickedImage != null) {
      return Card(
        clipBehavior: Clip.antiAlias,
        child: Stack(
          children: [
            ClipRRect(
              borderRadius: BorderRadius.circular(16),
              child: Image.file(
                File(_pickedImage!.path),
                height: 260,
                width: double.infinity,
                fit: BoxFit.cover,
              ),
            ),
            Positioned(
              top: 10,
              right: 10,
              child: Material(
                color: Colors.black54,
                borderRadius: BorderRadius.circular(20),
                child: InkWell(
                  borderRadius: BorderRadius.circular(20),
                  onTap: _reset,
                  child: const Padding(
                    padding: EdgeInsets.all(8),
                    child: Icon(Icons.close, size: 18, color: Colors.white),
                  ),
                ),
              ),
            ),
            if (_isAnalyzing)
              Positioned.fill(
                child: Container(
                  decoration: BoxDecoration(
                    color: Colors.black45,
                    borderRadius: BorderRadius.circular(16),
                  ),
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      const CircularProgressIndicator(color: Colors.white),
                      const SizedBox(height: 16),
                      Text(
                        'Analyzing image…',
                        style: GoogleFonts.prompt(
                          fontSize: 14,
                          fontWeight: FontWeight.w600,
                          color: Colors.white,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
          ],
        ),
      );
    }

    return AnimatedBuilder(
      animation: _pulseAnim,
      builder: (_, __) => Transform.scale(
        scale: _pulseAnim.value,
        child: Card(
          child: InkWell(
            onTap: _showImageSourceSheet,
            borderRadius: BorderRadius.circular(16),
            child: Container(
              height: 240,
              padding: const EdgeInsets.all(24),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Container(
                    padding: const EdgeInsets.all(16),
                    decoration: BoxDecoration(
                      color: cs.primaryContainer,
                      shape: BoxShape.circle,
                    ),
                    child: Icon(
                      Icons.add_a_photo_rounded,
                      size: 40,
                      color: cs.primary,
                    ),
                  ),
                  const SizedBox(height: 20),
                  Text(
                    'Tap to scan evidence',
                    style: GoogleFonts.prompt(
                      fontSize: 16,
                      fontWeight: FontWeight.w700,
                      color: cs.onSurface,
                    ),
                  ),
                  const SizedBox(height: 6),
                  Text(
                    'Take a photo or choose from gallery\nfor AI-powered analysis',
                    textAlign: TextAlign.center,
                    style: GoogleFonts.prompt(
                      fontSize: 12,
                      color: cs.onSurfaceVariant,
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildActions(ColorScheme cs) {
    if (_pickedImage == null) return const SizedBox.shrink();

    return Row(
      children: [
        Expanded(
          child: OutlinedButton.icon(
            onPressed: _showImageSourceSheet,
            icon: const Icon(Icons.swap_horiz_rounded, size: 20),
            label: Text('Change Photo', style: GoogleFonts.prompt()),
            style: OutlinedButton.styleFrom(
              padding: const EdgeInsets.symmetric(vertical: 14),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(12),
              ),
            ),
          ),
        ),
        const SizedBox(width: 12),
        Expanded(
          flex: 2,
          child: FilledButton.icon(
            onPressed: _isAnalyzing ? null : _analyzeImage,
            icon: _isAnalyzing
                ? const SizedBox(
                    width: 18,
                    height: 18,
                    child: CircularProgressIndicator(
                      strokeWidth: 2,
                      color: Colors.white,
                    ),
                  )
                : const Icon(Icons.smart_toy_rounded, size: 20),
            label: Text(
              _isAnalyzing ? 'Analyzing…' : 'Analyze with AI',
              style: GoogleFonts.prompt(fontWeight: FontWeight.w600),
            ),
            style: FilledButton.styleFrom(
              padding: const EdgeInsets.symmetric(vertical: 14),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(12),
              ),
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildResult(ThemeData theme, ColorScheme cs) {
    final sevColor = AppTheme.severityColor(_severity ?? 'Low');

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: cs.primaryContainer,
                    borderRadius: BorderRadius.circular(10),
                  ),
                  child: Icon(
                    Icons.analytics_rounded,
                    color: cs.primary,
                    size: 22,
                  ),
                ),
                const SizedBox(width: 12),
                Text(
                  'Analysis Result',
                  style: GoogleFonts.prompt(
                    fontSize: 16,
                    fontWeight: FontWeight.w700,
                    color: cs.onSurface,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 20),
            Container(
              width: double.infinity,
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: sevColor.withOpacity(0.08),
                borderRadius: BorderRadius.circular(12),
                border: Border.all(color: sevColor.withOpacity(0.3)),
              ),
              child: Row(
                children: [
                  Icon(Icons.warning_amber_rounded, color: sevColor, size: 24),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          _prediction!,
                          style: GoogleFonts.prompt(
                            fontSize: 14,
                            fontWeight: FontWeight.w700,
                            color: sevColor,
                          ),
                        ),
                        const SizedBox(height: 2),
                        Text(
                          'Severity: \${_severity ?? "Unknown"}',
                          style: GoogleFonts.prompt(
                            fontSize: 12,
                            color: sevColor.withOpacity(0.8),
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                Text(
                  'Confidence',
                  style: GoogleFonts.prompt(
                    fontSize: 13,
                    fontWeight: FontWeight.w500,
                    color: cs.onSurfaceVariant,
                  ),
                ),
                const Spacer(),
                Text(
                  '\${(_confidence * 100).toStringAsFixed(1)}%',
                  style: GoogleFonts.prompt(
                    fontSize: 16,
                    fontWeight: FontWeight.w800,
                    color: _confidence >= 0.8
                        ? AppTheme.severityLow
                        : _confidence >= 0.5
                        ? AppTheme.severityMedium
                        : AppTheme.severityHigh,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 8),
            ClipRRect(
              borderRadius: BorderRadius.circular(6),
              child: LinearProgressIndicator(
                value: _confidence,
                minHeight: 10,
                backgroundColor: cs.surfaceContainerHighest,
                color: _confidence >= 0.8
                    ? AppTheme.severityLow
                    : _confidence >= 0.5
                    ? AppTheme.severityMedium
                    : AppTheme.severityHigh,
              ),
            ),
            const SizedBox(height: 20),
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: cs.surfaceContainerHighest.withOpacity(0.3),
                borderRadius: BorderRadius.circular(10),
              ),
              child: Row(
                children: [
                  Icon(
                    Icons.info_outline,
                    size: 18,
                    color: cs.onSurfaceVariant,
                  ),
                  const SizedBox(width: 10),
                  Expanded(
                    child: Text(
                      'AI results are advisory only. Always verify with human review.',
                      style: GoogleFonts.prompt(
                        fontSize: 11,
                        color: cs.onSurfaceVariant,
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildHowItWorks(ThemeData theme, ColorScheme cs) {
    const steps = [
      (Icons.camera_alt_rounded, 'Capture', 'Take or select an evidence photo'),
      (Icons.smart_toy_rounded, 'Analyze', 'AI scans for election violations'),
      (
        Icons.assessment_rounded,
        'Results',
        'Get severity and confidence score',
      ),
    ];

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'How It Works',
          style: GoogleFonts.prompt(
            fontSize: 16,
            fontWeight: FontWeight.w700,
            color: cs.onSurface,
          ),
        ),
        const SizedBox(height: 16),
        ...steps.asMap().entries.map((entry) {
          final i = entry.key;
          final (icon, title, desc) = entry.value;
          return Padding(
            padding: const EdgeInsets.only(bottom: 12),
            child: Row(
              children: [
                Container(
                  width: 44,
                  height: 44,
                  decoration: BoxDecoration(
                    gradient: LinearGradient(
                      colors: [
                        AppTheme.chartColors[i],
                        AppTheme.chartColors[i].withOpacity(0.7),
                      ],
                    ),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Icon(icon, color: Colors.white, size: 22),
                ),
                const SizedBox(width: 14),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        title,
                        style: GoogleFonts.prompt(
                          fontSize: 14,
                          fontWeight: FontWeight.w700,
                          color: cs.onSurface,
                        ),
                      ),
                      Text(
                        desc,
                        style: GoogleFonts.prompt(
                          fontSize: 12,
                          color: cs.onSurfaceVariant,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          );
        }),
      ],
    );
  }
}
</file>

<file path="final66133505/lib/features/dashboard/presentation/page/home.dart">
import 'dart:async';

import 'package:fl_chart/fl_chart.dart';
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:intl/intl.dart';

import 'package:final66133505/core/database/database.dart';
import 'package:final66133505/core/di/injection.dart';
import 'package:final66133505/core/theme/app_theme.dart';

class MyHomePage extends StatefulWidget {
  const MyHomePage({super.key});

  @override
  State<MyHomePage> createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> with WidgetsBindingObserver {
  int _totalReports = 0;
  int _unsyncedCount = 0;
  int _totalStations = 0;
  List<IncidentReportEntity> _allReports = [];
  List<IncidentReportEntity> _recentReports = [];
  List<ViolationTypeEntity> _violationTypes = [];
  List<PollingStationEntity> _stations = [];
  bool _isLoading = true;
  SyncStatus _syncStatus = const SyncStatus();

  StreamSubscription<SyncStatus>? _syncSub;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    _loadDashboard();

    final syncManager = sl<AutoSyncManager>();
    _syncStatus = syncManager.currentStatus;
    _syncSub = syncManager.statusStream.listen((status) {
      // Reload on every sync completion so a delete on the Reports tab
      // is reflected here as soon as sync fires.
      if ((status.state == SyncState.synced ||
              status.state == SyncState.syncing) &&
          mounted) {
        _loadDashboard();
      }
      if (mounted) setState(() => _syncStatus = status);
    });
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    // Reload when app comes back to foreground.
    if (state == AppLifecycleState.resumed && mounted) {
      _loadDashboard();
    }
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _syncSub?.cancel();
    super.dispose();
  }

  Future<void> _loadDashboard() async {
    setState(() => _isLoading = true);
    try {
      final reports = await sl<IncidentReportRepository>().getAll();
      final unsynced = await sl<IncidentReportRepository>().getUnsyncedCount();
      final stations = await sl<PollingStationRepository>().getAll();
      final types = await sl<ViolationTypeRepository>().getAll();

      setState(() {
        _allReports = reports;
        _totalReports = reports.length;
        _unsyncedCount = unsynced;
        _totalStations = stations.length;
        _stations = stations;
        _violationTypes = types;
        _recentReports = reports.take(5).toList();
        _isLoading = false;
      });
    } catch (_) {
      setState(() => _isLoading = false);
    }
  }

  // ── Computed data for charts ──────────────────────────────────────────

  /// Severity distribution: { "High": n, "Medium": n, "Low": n }
  Map<String, int> get _severityCounts {
    final counts = <String, int>{'High': 0, 'Medium': 0, 'Low': 0};
    for (final r in _allReports) {
      final type = _violationTypes.where((t) => t.typeId == r.typeId);
      if (type.isNotEmpty) {
        final sev = type.first.severity;
        counts[sev] = (counts[sev] ?? 0) + 1;
      }
    }
    return counts;
  }

  /// Reports per station: { stationName: count }
  Map<String, int> get _stationCounts {
    final counts = <String, int>{};
    for (final r in _allReports) {
      final station = _stations.where((s) => s.stationId == r.stationId);
      if (station.isNotEmpty) {
        final name = station.first.stationName;
        final shortName = name.length > 12 ? '${name.substring(0, 12)}…' : name;
        counts[shortName] = (counts[shortName] ?? 0) + 1;
      }
    }
    return counts;
  }

  /// Reports per violation type
  Map<String, int> get _typeCounts {
    final counts = <String, int>{};
    for (final r in _allReports) {
      final type = _violationTypes.where((t) => t.typeId == r.typeId);
      if (type.isNotEmpty) {
        final name = type.first.typeName;
        final shortName = name.contains('(')
            ? name.substring(0, name.indexOf('(')).trim()
            : (name.length > 15 ? '${name.substring(0, 15)}…' : name);
        counts[shortName] = (counts[shortName] ?? 0) + 1;
      }
    }
    return counts;
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final cs = theme.colorScheme;

    if (_isLoading) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            CircularProgressIndicator(color: cs.primary),
            const SizedBox(height: 16),
            Text(
              'Loading dashboard…',
              style: theme.textTheme.bodyMedium?.copyWith(
                color: cs.onSurfaceVariant,
              ),
            ),
          ],
        ),
      );
    }

    return RefreshIndicator(
      onRefresh: _loadDashboard,
      child: ListView(
        padding: const EdgeInsets.fromLTRB(20, 16, 20, 32),
        children: [
          // ── Header ─────────────────────────────────────────────────
          _buildHeader(theme, cs),
          const SizedBox(height: 20),

          // ── KPI Stats Row ──────────────────────────────────────────
          _buildStatsRow(cs),
          const SizedBox(height: 24),

          // ── Quick Actions ──────────────────────────────────────────
          _buildQuickActions(theme, cs),
          const SizedBox(height: 24),

          // ── Charts ─────────────────────────────────────────────────
          if (_allReports.isNotEmpty) ...[
            _buildSectionTitle(theme, 'Severity Distribution'),
            const SizedBox(height: 12),
            _SeverityPieChart(severityCounts: _severityCounts),
            const SizedBox(height: 24),

            _buildSectionTitle(theme, 'Reports by Station'),
            const SizedBox(height: 12),
            _StationBarChart(
              stationCounts: _stationCounts,
              chartColors: AppTheme.chartColors,
            ),
            const SizedBox(height: 24),

            _buildSectionTitle(theme, 'Reports by Type'),
            const SizedBox(height: 12),
            _TypeBarChart(typeCounts: _typeCounts),
            const SizedBox(height: 24),
          ],

          // ── Recent Reports ─────────────────────────────────────────
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              _buildSectionTitle(theme, 'Recent Reports'),
              TextButton.icon(
                onPressed: () => context.go('/reports'),
                icon: const Icon(Icons.arrow_forward_rounded, size: 18),
                label: const Text('View All'),
              ),
            ],
          ),
          const SizedBox(height: 8),
          _buildRecentReports(theme, cs),
        ],
      ),
    );
  }

  // ── Header ──────────────────────────────────────────────────────────────

  Widget _buildHeader(ThemeData theme, ColorScheme cs) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Container(
          padding: const EdgeInsets.all(10),
          decoration: BoxDecoration(
            color: cs.primaryContainer,
            borderRadius: BorderRadius.circular(14),
          ),
          child: Icon(Icons.how_to_vote_rounded, size: 28, color: cs.primary),
        ),
        const SizedBox(width: 14),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'Election Monitor',
                style: GoogleFonts.prompt(
                  fontSize: 22,
                  fontWeight: FontWeight.w800,
                  color: cs.onSurface,
                ),
              ),
              const SizedBox(height: 2),
              Text(
                DateFormat('EEEE, d MMMM y').format(DateTime.now()),
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: cs.onSurfaceVariant,
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }

  // ── Stats Row ───────────────────────────────────────────────────────────

  Widget _buildStatsRow(ColorScheme cs) {
    return Row(
      children: [
        Expanded(
          child: _KPICard(
            icon: Icons.assignment_rounded,
            label: 'Reports',
            value: '$_totalReports',
            gradient: const [Color(0xFF0D47A1), Color(0xFF1976D2)],
          ),
        ),
        const SizedBox(width: 10),
        Expanded(
          child: _KPICard(
            icon: Icons.cloud_upload_rounded,
            label: 'Unsynced',
            value: '$_unsyncedCount',
            gradient: _unsyncedCount > 0
                ? const [Color(0xFFE65100), Color(0xFFEF6C00)]
                : const [Color(0xFF2E7D32), Color(0xFF43A047)],
          ),
        ),
        const SizedBox(width: 10),
        Expanded(
          child: _KPICard(
            icon: Icons.location_on_rounded,
            label: 'Stations',
            value: '$_totalStations',
            gradient: const [Color(0xFF00796B), Color(0xFF26A69A)],
          ),
        ),
      ],
    );
  }

  // ── Quick Actions ───────────────────────────────────────────────────────

  Widget _buildQuickActions(ThemeData theme, ColorScheme cs) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildSectionTitle(theme, 'Quick Actions'),
        const SizedBox(height: 12),
        Row(
          children: [
            Expanded(
              child: _ActionChip(
                icon: Icons.add_circle_outline_rounded,
                label: 'New Report',
                color: cs.primary,
                onTap: () => context.push('/reports/add'),
              ),
            ),
            const SizedBox(width: 10),
            Expanded(
              child: _ActionChip(
                icon: _syncStatus.isSyncing
                    ? Icons.hourglass_top_rounded
                    : Icons.sync_rounded,
                label: _syncStatus.isSyncing ? 'Syncing…' : 'Sync Now',
                color: const Color(0xFFD4A017),
                onTap: () async {
                  if (!_syncStatus.isSyncing) {
                    await sl<AutoSyncManager>().requestSync();
                    _loadDashboard();
                  }
                },
              ),
            ),
            const SizedBox(width: 10),
            Expanded(
              child: _ActionChip(
                icon: Icons.list_alt_rounded,
                label: 'All Reports',
                color: const Color(0xFF00796B),
                onTap: () => context.go('/reports'),
              ),
            ),
          ],
        ),
      ],
    );
  }

  // ── Recent Reports ──────────────────────────────────────────────────────

  Widget _buildRecentReports(ThemeData theme, ColorScheme cs) {
    if (_recentReports.isEmpty) {
      return Card(
        child: Padding(
          padding: const EdgeInsets.all(40),
          child: Column(
            children: [
              Icon(
                Icons.inbox_outlined,
                size: 48,
                color: cs.onSurfaceVariant.withOpacity(0.3),
              ),
              const SizedBox(height: 12),
              Text(
                'No reports yet',
                style: theme.textTheme.bodyLarge?.copyWith(
                  color: cs.onSurfaceVariant,
                ),
              ),
              const SizedBox(height: 8),
              Text(
                'Tap "New Report" to add one',
                style: theme.textTheme.bodySmall?.copyWith(
                  color: cs.onSurfaceVariant.withOpacity(0.6),
                ),
              ),
            ],
          ),
        ),
      );
    }

    return Column(
      children: _recentReports.map((r) {
        final type = _violationTypes.where((t) => t.typeId == r.typeId);
        final severity = type.isNotEmpty ? type.first.severity : 'Low';

        return _RecentReportTile(
          report: r,
          severityColor: AppTheme.severityColor(severity),
          onTap: () => context.push('/reports/detail/${r.reportId}'),
        );
      }).toList(),
    );
  }

  // ── Section Title ───────────────────────────────────────────────────────

  Widget _buildSectionTitle(ThemeData theme, String title) {
    return Text(
      title,
      style: GoogleFonts.prompt(
        fontSize: 16,
        fontWeight: FontWeight.w700,
        color: theme.colorScheme.onSurface,
      ),
    );
  }
}

// ═════════════════════════════════════════════════════════════════════════════
// KPI Card — gradient background stat card
// ═════════════════════════════════════════════════════════════════════════════

class _KPICard extends StatelessWidget {
  final IconData icon;
  final String label;
  final String value;
  final List<Color> gradient;

  const _KPICard({
    required this.icon,
    required this.label,
    required this.value,
    required this.gradient,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(vertical: 18, horizontal: 14),
      decoration: BoxDecoration(
        gradient: LinearGradient(
          colors: gradient,
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: gradient.first.withOpacity(0.3),
            blurRadius: 10,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Column(
        children: [
          Icon(icon, color: Colors.white.withOpacity(0.9), size: 26),
          const SizedBox(height: 8),
          Text(
            value,
            style: GoogleFonts.prompt(
              fontSize: 24,
              fontWeight: FontWeight.w800,
              color: Colors.white,
            ),
          ),
          const SizedBox(height: 2),
          Text(
            label,
            style: GoogleFonts.prompt(
              fontSize: 11,
              fontWeight: FontWeight.w500,
              color: Colors.white.withOpacity(0.85),
            ),
          ),
        ],
      ),
    );
  }
}

// ═════════════════════════════════════════════════════════════════════════════
// Action Chip — quick action button
// ═════════════════════════════════════════════════════════════════════════════

class _ActionChip extends StatelessWidget {
  final IconData icon;
  final String label;
  final Color color;
  final VoidCallback onTap;

  const _ActionChip({
    required this.icon,
    required this.label,
    required this.color,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return Material(
      color: color.withOpacity(0.08),
      borderRadius: BorderRadius.circular(14),
      child: InkWell(
        borderRadius: BorderRadius.circular(14),
        onTap: onTap,
        child: Padding(
          padding: const EdgeInsets.symmetric(vertical: 16, horizontal: 8),
          child: Column(
            children: [
              Container(
                padding: const EdgeInsets.all(10),
                decoration: BoxDecoration(
                  color: color.withOpacity(0.12),
                  shape: BoxShape.circle,
                ),
                child: Icon(icon, color: color, size: 22),
              ),
              const SizedBox(height: 8),
              Text(
                label,
                style: GoogleFonts.prompt(
                  fontSize: 11,
                  fontWeight: FontWeight.w600,
                  color: color,
                ),
                textAlign: TextAlign.center,
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
              ),
            ],
          ),
        ),
      ),
    );
  }
}

// ═════════════════════════════════════════════════════════════════════════════
// Severity Pie Chart
// ═════════════════════════════════════════════════════════════════════════════

class _SeverityPieChart extends StatelessWidget {
  final Map<String, int> severityCounts;

  const _SeverityPieChart({required this.severityCounts});

  @override
  Widget build(BuildContext context) {
    final total = severityCounts.values.fold(0, (a, b) => a + b);
    if (total == 0) return const SizedBox.shrink();

    final entries = severityCounts.entries.where((e) => e.value > 0).toList();

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Row(
          children: [
            // ── Pie ───────────────────────────────────────────────────
            SizedBox(
              width: 130,
              height: 130,
              child: PieChart(
                PieChartData(
                  sectionsSpace: 3,
                  centerSpaceRadius: 28,
                  sections: entries.map((e) {
                    final pct = (e.value / total * 100).round();
                    return PieChartSectionData(
                      value: e.value.toDouble(),
                      color: AppTheme.severityColor(e.key),
                      radius: 38,
                      title: '$pct%',
                      titleStyle: GoogleFonts.prompt(
                        fontSize: 11,
                        fontWeight: FontWeight.w700,
                        color: Colors.white,
                      ),
                    );
                  }).toList(),
                ),
              ),
            ),
            const SizedBox(width: 24),

            // ── Legend ─────────────────────────────────────────────────
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: entries.map((e) {
                  return Padding(
                    padding: const EdgeInsets.symmetric(vertical: 4),
                    child: Row(
                      children: [
                        Container(
                          width: 14,
                          height: 14,
                          decoration: BoxDecoration(
                            color: AppTheme.severityColor(e.key),
                            borderRadius: BorderRadius.circular(4),
                          ),
                        ),
                        const SizedBox(width: 10),
                        Text(
                          e.key,
                          style: GoogleFonts.prompt(
                            fontSize: 13,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                        const Spacer(),
                        Text(
                          '${e.value}',
                          style: GoogleFonts.prompt(
                            fontSize: 14,
                            fontWeight: FontWeight.w700,
                            color: Theme.of(
                              context,
                            ).colorScheme.onSurfaceVariant,
                          ),
                        ),
                      ],
                    ),
                  );
                }).toList(),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

// ═════════════════════════════════════════════════════════════════════════════
// Station Bar Chart
// ═════════════════════════════════════════════════════════════════════════════

class _StationBarChart extends StatelessWidget {
  final Map<String, int> stationCounts;
  final List<Color> chartColors;

  const _StationBarChart({
    required this.stationCounts,
    required this.chartColors,
  });

  @override
  Widget build(BuildContext context) {
    final entries = stationCounts.entries.toList();
    if (entries.isEmpty) return const SizedBox.shrink();

    final maxVal = entries
        .map((e) => e.value)
        .reduce((a, b) => a > b ? a : b)
        .toDouble();

    return Card(
      child: Padding(
        padding: const EdgeInsets.fromLTRB(16, 20, 20, 16),
        child: SizedBox(
          height: (entries.length * 50).toDouble().clamp(100, 250),
          child: BarChart(
            BarChartData(
              alignment: BarChartAlignment.spaceAround,
              maxY: maxVal + 1,
              barTouchData: BarTouchData(
                enabled: true,
                touchTooltipData: BarTouchTooltipData(
                  getTooltipItem: (group, groupIndex, rod, rodIndex) {
                    return BarTooltipItem(
                      '${entries[group.x.toInt()].key}\n',
                      GoogleFonts.prompt(
                        fontSize: 11,
                        fontWeight: FontWeight.w500,
                        color: Colors.white,
                      ),
                      children: [
                        TextSpan(
                          text: '${rod.toY.toInt()} reports',
                          style: GoogleFonts.prompt(
                            fontSize: 12,
                            fontWeight: FontWeight.w700,
                            color: Colors.white,
                          ),
                        ),
                      ],
                    );
                  },
                ),
              ),
              titlesData: FlTitlesData(
                leftTitles: AxisTitles(
                  sideTitles: SideTitles(
                    showTitles: true,
                    reservedSize: 28,
                    getTitlesWidget: (value, meta) {
                      if (value == value.roundToDouble() && value >= 0) {
                        return Text(
                          '${value.toInt()}',
                          style: GoogleFonts.prompt(
                            fontSize: 10,
                            color: Theme.of(
                              context,
                            ).colorScheme.onSurfaceVariant,
                          ),
                        );
                      }
                      return const SizedBox.shrink();
                    },
                  ),
                ),
                bottomTitles: AxisTitles(
                  sideTitles: SideTitles(
                    showTitles: true,
                    reservedSize: 42,
                    getTitlesWidget: (value, meta) {
                      final idx = value.toInt();
                      if (idx >= 0 && idx < entries.length) {
                        return SideTitleWidget(
                          meta: meta,
                          child: Text(
                            entries[idx].key,
                            style: GoogleFonts.prompt(fontSize: 8),
                            textAlign: TextAlign.center,
                            maxLines: 2,
                            overflow: TextOverflow.ellipsis,
                          ),
                        );
                      }
                      return const SizedBox.shrink();
                    },
                  ),
                ),
                topTitles: const AxisTitles(
                  sideTitles: SideTitles(showTitles: false),
                ),
                rightTitles: const AxisTitles(
                  sideTitles: SideTitles(showTitles: false),
                ),
              ),
              gridData: FlGridData(
                show: true,
                drawVerticalLine: false,
                horizontalInterval: 1,
                getDrawingHorizontalLine: (value) {
                  return FlLine(color: Colors.grey.shade200, strokeWidth: 1);
                },
              ),
              borderData: FlBorderData(show: false),
              barGroups: List.generate(entries.length, (i) {
                return BarChartGroupData(
                  x: i,
                  barRods: [
                    BarChartRodData(
                      toY: entries[i].value.toDouble(),
                      color: chartColors[i % chartColors.length],
                      width: 22,
                      borderRadius: const BorderRadius.only(
                        topLeft: Radius.circular(6),
                        topRight: Radius.circular(6),
                      ),
                    ),
                  ],
                );
              }),
            ),
          ),
        ),
      ),
    );
  }
}

// ═════════════════════════════════════════════════════════════════════════════
// Violation Type Bar Chart
// ═════════════════════════════════════════════════════════════════════════════

class _TypeBarChart extends StatelessWidget {
  final Map<String, int> typeCounts;

  const _TypeBarChart({required this.typeCounts});

  @override
  Widget build(BuildContext context) {
    final entries = typeCounts.entries.toList();
    if (entries.isEmpty) return const SizedBox.shrink();

    final maxVal = entries
        .map((e) => e.value)
        .reduce((a, b) => a > b ? a : b)
        .toDouble();

    return Card(
      child: Padding(
        padding: const EdgeInsets.fromLTRB(16, 20, 20, 16),
        child: SizedBox(
          height: (entries.length * 50).toDouble().clamp(100, 250),
          child: BarChart(
            BarChartData(
              alignment: BarChartAlignment.spaceAround,
              maxY: maxVal + 1,
              barTouchData: BarTouchData(
                enabled: true,
                touchTooltipData: BarTouchTooltipData(
                  getTooltipItem: (group, groupIndex, rod, rodIndex) {
                    return BarTooltipItem(
                      '${entries[group.x.toInt()].key}\n',
                      GoogleFonts.prompt(
                        fontSize: 11,
                        fontWeight: FontWeight.w500,
                        color: Colors.white,
                      ),
                      children: [
                        TextSpan(
                          text: '${rod.toY.toInt()} reports',
                          style: GoogleFonts.prompt(
                            fontSize: 12,
                            fontWeight: FontWeight.w700,
                            color: Colors.white,
                          ),
                        ),
                      ],
                    );
                  },
                ),
              ),
              titlesData: FlTitlesData(
                leftTitles: AxisTitles(
                  sideTitles: SideTitles(
                    showTitles: true,
                    reservedSize: 28,
                    getTitlesWidget: (value, meta) {
                      if (value == value.roundToDouble() && value >= 0) {
                        return Text(
                          '${value.toInt()}',
                          style: GoogleFonts.prompt(
                            fontSize: 10,
                            color: Theme.of(
                              context,
                            ).colorScheme.onSurfaceVariant,
                          ),
                        );
                      }
                      return const SizedBox.shrink();
                    },
                  ),
                ),
                bottomTitles: AxisTitles(
                  sideTitles: SideTitles(
                    showTitles: true,
                    reservedSize: 42,
                    getTitlesWidget: (value, meta) {
                      final idx = value.toInt();
                      if (idx >= 0 && idx < entries.length) {
                        return SideTitleWidget(
                          meta: meta,
                          child: Text(
                            entries[idx].key,
                            style: GoogleFonts.prompt(fontSize: 8),
                            textAlign: TextAlign.center,
                            maxLines: 2,
                            overflow: TextOverflow.ellipsis,
                          ),
                        );
                      }
                      return const SizedBox.shrink();
                    },
                  ),
                ),
                topTitles: const AxisTitles(
                  sideTitles: SideTitles(showTitles: false),
                ),
                rightTitles: const AxisTitles(
                  sideTitles: SideTitles(showTitles: false),
                ),
              ),
              gridData: FlGridData(
                show: true,
                drawVerticalLine: false,
                horizontalInterval: 1,
                getDrawingHorizontalLine: (value) {
                  return FlLine(color: Colors.grey.shade200, strokeWidth: 1);
                },
              ),
              borderData: FlBorderData(show: false),
              barGroups: List.generate(entries.length, (i) {
                const colors = [
                  Color(0xFF6A1B9A),
                  Color(0xFFD4A017),
                  Color(0xFFC62828),
                  Color(0xFF0D47A1),
                  Color(0xFF00796B),
                ];
                return BarChartGroupData(
                  x: i,
                  barRods: [
                    BarChartRodData(
                      toY: entries[i].value.toDouble(),
                      color: colors[i % colors.length],
                      width: 22,
                      borderRadius: const BorderRadius.only(
                        topLeft: Radius.circular(6),
                        topRight: Radius.circular(6),
                      ),
                    ),
                  ],
                );
              }),
            ),
          ),
        ),
      ),
    );
  }
}

// ═════════════════════════════════════════════════════════════════════════════
// Recent Report Tile
// ═════════════════════════════════════════════════════════════════════════════

class _RecentReportTile extends StatelessWidget {
  final IncidentReportEntity report;
  final Color severityColor;
  final VoidCallback onTap;

  const _RecentReportTile({
    required this.report,
    required this.severityColor,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final date = DateTime.tryParse(report.timestamp) ?? DateTime.now();
    final formattedDate = DateFormat('dd/MM/yyyy HH:mm').format(date);

    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(16),
        child: Padding(
          padding: const EdgeInsets.all(14),
          child: Row(
            children: [
              // ── Severity indicator bar ────────────────────────────
              Container(
                width: 4,
                height: 44,
                decoration: BoxDecoration(
                  color: severityColor,
                  borderRadius: BorderRadius.circular(4),
                ),
              ),
              const SizedBox(width: 14),

              // ── Sync status icon ──────────────────────────────────
              Container(
                padding: const EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: report.isSynced
                      ? AppTheme.syncedColor.withOpacity(0.1)
                      : AppTheme.pendingColor.withOpacity(0.1),
                  shape: BoxShape.circle,
                ),
                child: Icon(
                  report.isSynced
                      ? Icons.cloud_done_rounded
                      : Icons.schedule_rounded,
                  color: report.isSynced
                      ? AppTheme.syncedColor
                      : AppTheme.pendingColor,
                  size: 18,
                ),
              ),
              const SizedBox(width: 12),

              // ── Text ──────────────────────────────────────────────
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      report.description,
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                      style: GoogleFonts.prompt(
                        fontSize: 13,
                        fontWeight: FontWeight.w600,
                        color: theme.colorScheme.onSurface,
                      ),
                    ),
                    const SizedBox(height: 3),
                    Text(
                      '$formattedDate  •  ${report.reporterName}',
                      style: GoogleFonts.prompt(
                        fontSize: 11,
                        color: theme.colorScheme.onSurfaceVariant,
                      ),
                    ),
                  ],
                ),
              ),

              Icon(
                Icons.chevron_right_rounded,
                color: theme.colorScheme.onSurfaceVariant,
              ),
            ],
          ),
        ),
      ),
    );
  }
}
</file>

<file path="final66133505/lib/features/report/domain/entities/incident_report.dart">
/// Domain model for displaying an incident report in the UI.
///
/// Combines data from `incident_report`, `polling_station`, and
/// `violation_type` tables for a complete view.
class IncidentReport {
  final int id;
  final String description;
  final DateTime date;
  final String reporterName;

  // Polling station info
  final int stationId;
  final String stationName;
  final String zone;
  final String province;

  // Violation type info
  final int typeId;
  final String violationTypeName;
  final String severity;

  // AI analysis
  final String? aiResult;
  final double aiConfidence;

  // Evidence
  final String? evidencePhoto;

  // Sync status
  final bool isSynced;

  const IncidentReport({
    required this.id,
    required this.description,
    required this.date,
    required this.reporterName,
    required this.stationId,
    required this.stationName,
    required this.zone,
    required this.province,
    required this.typeId,
    required this.violationTypeName,
    required this.severity,
    this.aiResult,
    this.aiConfidence = 0.0,
    this.evidencePhoto,
    this.isSynced = false,
  });

  /// User-friendly title combining AI result or violation type name.
  String get title =>
      aiResult != null && aiResult!.isNotEmpty ? aiResult! : violationTypeName;

  /// Full location label.
  String get locationLabel => '$stationName ($zone, $province)';
}
</file>

<file path="final66133505/lib/features/report/presentation/page/add_report_page.dart">
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:image_picker/image_picker.dart';
import 'package:logging/logging.dart';

import 'package:final66133505/core/database/database.dart';
import 'package:final66133505/core/di/injection.dart';
import 'package:final66133505/core/theme/app_theme.dart';
import 'package:final66133505/core/utils/image_storage.dart';
import 'package:final66133505/core/utils/tflite_classifier.dart';

class AddReportPage extends StatefulWidget {
  const AddReportPage({super.key});

  @override
  State<AddReportPage> createState() => _AddReportPageState();
}

class _AddReportPageState extends State<AddReportPage> {
  static final _log = Logger('AddReportPage');

  final _formKey = GlobalKey<FormState>();
  final _descriptionCtrl = TextEditingController();
  final _reporterCtrl = TextEditingController();

  List<PollingStationEntity> _stations = [];
  List<ViolationTypeEntity> _types = [];

  int? _selectedStationId;
  int? _selectedTypeId;
  bool _isSaving = false;
  bool _isLoading = true;

  // Image picker
  final ImagePicker _picker = ImagePicker();
  XFile? _pickedImage;
  bool _isAnalyzing = false;
  String? _aiPrediction;
  double _aiConfidence = 0.0;

  @override
  void initState() {
    super.initState();
    _loadDropdowns();
  }

  @override
  void dispose() {
    _descriptionCtrl.dispose();
    _reporterCtrl.dispose();
    super.dispose();
  }

  Future<void> _loadDropdowns() async {
    try {
      final stations = await sl<PollingStationRepository>().getAll();
      final types = await sl<ViolationTypeRepository>().getAll();

      setState(() {
        _stations = stations;
        _types = types;
        _isLoading = false;
      });
    } catch (e, s) {
      _log.severe('Failed to load dropdown data', e, s);
      setState(() => _isLoading = false);
    }
  }

  // ── Add-new dialogs ─────────────────────────────────────────────────

  Future<void> _addNewStation() async {
    final idCtrl = TextEditingController();
    final nameCtrl = TextEditingController();
    final zoneCtrl = TextEditingController();
    final provinceCtrl = TextEditingController();
    final formKey = GlobalKey<FormState>();

    try {
      final confirmed = await showDialog<bool>(
        context: context,
        builder: (ctx) => AlertDialog(
          title: Text(
            'New Polling Station',
            style: GoogleFonts.prompt(fontWeight: FontWeight.w700),
          ),
          content: SingleChildScrollView(
            child: Form(
              key: formKey,
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  TextFormField(
                    controller: idCtrl,
                    autofocus: true,
                    keyboardType: TextInputType.number,
                    decoration: const InputDecoration(
                      labelText: 'Station ID *',
                      hintText: 'e.g. 101',
                    ),
                    validator: (v) {
                      if (v == null || v.trim().isEmpty) return 'Required';
                      final parsed = int.tryParse(v.trim());
                      if (parsed == null) return 'Must be a number';
                      if (parsed <= 0) return 'Must be > 0';
                      if (_stations.any((s) => s.stationId == parsed)) {
                        return 'ID $parsed already exists';
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 8),
                  TextFormField(
                    controller: nameCtrl,
                    decoration: const InputDecoration(labelText: 'Station name *'),
                    validator: (v) =>
                        (v == null || v.trim().isEmpty) ? 'Required' : null,
                  ),
                  const SizedBox(height: 8),
                  TextFormField(
                    controller: zoneCtrl,
                    decoration: const InputDecoration(labelText: 'Zone *'),
                    validator: (v) =>
                        (v == null || v.trim().isEmpty) ? 'Required' : null,
                  ),
                  const SizedBox(height: 8),
                  TextFormField(
                    controller: provinceCtrl,
                    decoration: const InputDecoration(labelText: 'Province *'),
                    validator: (v) =>
                        (v == null || v.trim().isEmpty) ? 'Required' : null,
                  ),
                ],
              ),
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(ctx).pop(false),
              child: const Text('Cancel'),
            ),
            FilledButton(
              onPressed: () {
                if (formKey.currentState!.validate()) {
                  Navigator.of(ctx).pop(true);
                }
              },
              child: const Text('Add'),
            ),
          ],
        ),
      );

      if (confirmed == true && mounted) {
        final newStation = await sl<PollingStationRepository>().create(
          stationId: int.tryParse(idCtrl.text.trim()),
          name: nameCtrl.text,
          zone: zoneCtrl.text,
          province: provinceCtrl.text,
        );
        if (mounted) {
          setState(() {
            // Remove any stale entry with the same ID before appending
            _stations = [
              ..._stations.where((s) => s.stationId != newStation.stationId),
              newStation,
            ];
            _selectedStationId = newStation.stationId;
          });
        }
      }
    } catch (e) {
      if (mounted) {
        _showErrorDialog('Failed to add station', e.toString());
      }
    }
    // Do NOT call dispose() here — the dialog close animation is still
    // running on the next frame and the TextFormField widgets still hold
    // references to these controllers. Local controllers created inside
    // an async method are short-lived and Dart GC handles them safely.
  }

  Future<void> _addNewType() async {
    final nameCtrl = TextEditingController();
    String selectedSeverity = 'Medium';
    final formKey = GlobalKey<FormState>();

    try {
      final confirmed = await showDialog<bool>(
        context: context,
        builder: (ctx) => StatefulBuilder(
          builder: (ctx, setInner) => AlertDialog(
            title: Text(
              'New Violation Type',
              style: GoogleFonts.prompt(fontWeight: FontWeight.w700),
            ),
            content: Form(
              key: formKey,
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  TextFormField(
                    controller: nameCtrl,
                    autofocus: true,
                    decoration: const InputDecoration(
                      labelText: 'Violation name *',
                    ),
                    validator: (v) =>
                        (v == null || v.trim().isEmpty) ? 'Required' : null,
                  ),
                  const SizedBox(height: 12),
                  DropdownButtonFormField<String>(
                    value: selectedSeverity,
                    decoration: const InputDecoration(labelText: 'Severity'),
                    items: const [
                      DropdownMenuItem(value: 'High', child: Text('High')),
                      DropdownMenuItem(
                        value: 'Medium',
                        child: Text('Medium'),
                      ),
                      DropdownMenuItem(value: 'Low', child: Text('Low')),
                    ],
                    onChanged: (v) => setInner(() => selectedSeverity = v!),
                  ),
                ],
              ),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(ctx).pop(false),
                child: const Text('Cancel'),
              ),
              FilledButton(
                onPressed: () {
                  if (formKey.currentState!.validate()) {
                    Navigator.of(ctx).pop(true);
                  }
                },
                child: const Text('Add'),
              ),
            ],
          ),
        ),
      );

      if (confirmed == true && mounted) {
        final newType = await sl<ViolationTypeRepository>().create(
          name: nameCtrl.text,
          severity: selectedSeverity,
        );
        if (mounted) {
          setState(() {
            _types = [..._types, newType];
            _selectedTypeId = newType.typeId;
          });
        }
      }
    } catch (e) {
      if (mounted) {
        _showErrorDialog('Failed to add violation type', e.toString());
      }
    }
    // Do NOT dispose — same reason as _addNewStation above.
  }

  void _showErrorDialog(String title, String message) {
    if (!mounted) return;
    showDialog<void>(
      context: context,
      builder: (ctx) => AlertDialog(
        icon: const Icon(Icons.error_outline_rounded, color: Colors.red, size: 40),
        title: Text(title, style: GoogleFonts.prompt(fontWeight: FontWeight.w700)),
        content: Text(message, style: GoogleFonts.prompt()),
        actions: [
          FilledButton(
            onPressed: () => Navigator.of(ctx).pop(),
            child: const Text('OK'),
          ),
        ],
      ),
    );
  }

  Future<void> _pickImage(ImageSource source) async {
    try {
      final image = await _picker.pickImage(
        source: source,
        maxWidth: 1024,
        maxHeight: 1024,
        imageQuality: 85,
      );
      if (image != null) {
        // Copy to persistent temp dir so the path survives process restarts.
        final persistentPath = await ImageStorage.copyToTemp(image.path);
        setState(() {
          _pickedImage = XFile(persistentPath);
          _aiPrediction = null;
          _aiConfidence = 0.0;
        });
        // Auto-predict immediately after picking
        _analyzeImage();
      }
    } catch (e) {
      _log.warning('Image pick failed: $e');
      if (mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text('Failed to pick image: $e')));
      }
    }
  }

  void _showImageSourceSheet() {
    showModalBottomSheet(
      context: context,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (ctx) => SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(vertical: 16),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Container(
                width: 40,
                height: 4,
                decoration: BoxDecoration(
                  color: Colors.grey.shade300,
                  borderRadius: BorderRadius.circular(2),
                ),
              ),
              const SizedBox(height: 16),
              Text(
                'Select Image Source',
                style: GoogleFonts.prompt(
                  fontSize: 16,
                  fontWeight: FontWeight.w700,
                ),
              ),
              const SizedBox(height: 16),
              ListTile(
                leading: CircleAvatar(
                  backgroundColor: Theme.of(ctx).colorScheme.primaryContainer,
                  child: Icon(
                    Icons.camera_alt_rounded,
                    color: Theme.of(ctx).colorScheme.primary,
                  ),
                ),
                title: const Text('Camera'),
                subtitle: const Text('Take a new photo'),
                onTap: () {
                  Navigator.pop(ctx);
                  _pickImage(ImageSource.camera);
                },
              ),
              ListTile(
                leading: CircleAvatar(
                  backgroundColor: Theme.of(ctx).colorScheme.secondaryContainer,
                  child: Icon(
                    Icons.photo_library_rounded,
                    color: Theme.of(ctx).colorScheme.secondary,
                  ),
                ),
                title: const Text('Gallery'),
                subtitle: const Text('Choose from gallery'),
                onTap: () {
                  Navigator.pop(ctx);
                  _pickImage(ImageSource.gallery);
                },
              ),
            ],
          ),
        ),
      ),
    );
  }

  Future<void> _analyzeImage() async {
    if (_pickedImage == null) return;

    setState(() => _isAnalyzing = true);

    try {
      await tfliteClassifier.init();
      final result = await tfliteClassifier.classify(File(_pickedImage!.path));

      if (result != null) {
        setState(() {
          _aiPrediction = result.label;
          _aiConfidence = result.confidence;
        });
      } else {
        if (mounted) {
          _showErrorDialog(
            'Analysis Failed',
            'Could not classify this image.\nPlease try a clearer photo.',
          );
        }
      }
    } catch (e) {
      _log.warning('AI analysis error: $e');
      if (mounted) {
        _showErrorDialog('AI Error', 'Image analysis encountered an error:\n$e');
      }
    } finally {
      if (mounted) setState(() => _isAnalyzing = false);
    }
  }

  Future<void> _submit() async {
    if (!_formKey.currentState!.validate()) return;
    if (_selectedStationId == null || _selectedTypeId == null) return;

    setState(() => _isSaving = true);

    try {
      final now = DateTime.now();
      final timestamp = now.toIso8601String();

      final report = IncidentReportEntity(
        stationId: _selectedStationId!,
        typeId: _selectedTypeId!,
        reporterName: _reporterCtrl.text.trim(),
        description: _descriptionCtrl.text.trim(),
        timestamp: timestamp,
        evidencePhoto: _pickedImage?.path,
        aiResult: _aiPrediction,
        aiConfidence: _aiConfidence,
      );

      await sl<IncidentReportRepository>().create(report);

      // Trigger background auto-sync immediately.
      sl<AutoSyncManager>().requestSync();

      _log.info('Report created successfully');

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Report created successfully ✓')),
        );
        context.pop(true);
      }
    } catch (e, s) {
      _log.severe('Failed to create report', e, s);
      if (mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text('Failed to create report: $e')));
      }
    } finally {
      if (mounted) setState(() => _isSaving = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Scaffold(
      appBar: AppBar(
        title: Text(
          'New Report',
          style: GoogleFonts.prompt(fontWeight: FontWeight.w700),
        ),
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : SingleChildScrollView(
              padding: const EdgeInsets.fromLTRB(20, 8, 20, 32),
              child: Form(
                key: _formKey,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    // ── Evidence Photo ──────────────────────────────────
                    _buildImageSection(theme, colorScheme),

                    const SizedBox(height: 16),

                    // ── Polling Station ─────────────────────────────────
                    _buildSectionLabel(
                      theme,
                      Icons.how_to_vote_outlined,
                      'Polling Station',
                    ),
                    const SizedBox(height: 8),
                    DropdownButtonFormField<int>(
                      value: _selectedStationId,
                      decoration: const InputDecoration(
                        hintText: 'Select a polling station',
                      ),
                      isExpanded: true,
                      items: [
                        ..._stations.map(
                          (s) => DropdownMenuItem(
                            value: s.stationId,
                            child: Text(
                              '${s.stationName} (${s.zone})',
                              overflow: TextOverflow.ellipsis,
                            ),
                          ),
                        ),
                        DropdownMenuItem(
                          value: -1,
                          child: Row(
                            children: [
                              const Icon(Icons.add_circle_outline, size: 18),
                              const SizedBox(width: 6),
                              Text(
                                'Add new station…',
                                style: GoogleFonts.prompt(
                                  fontStyle: FontStyle.italic,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ],
                      onChanged: (val) {
                        if (val == -1) {
                          _addNewStation();
                        } else {
                          setState(() => _selectedStationId = val);
                        }
                      },
                      validator: (val) => (val == null || val == -1)
                          ? 'Please select a station'
                          : null,
                    ),

                    const SizedBox(height: 20),

                    // ── Violation Type ──────────────────────────────────
                    _buildSectionLabel(
                      theme,
                      Icons.gavel_outlined,
                      'Violation Type',
                    ),
                    const SizedBox(height: 8),
                    DropdownButtonFormField<int>(
                      value: _selectedTypeId,
                      decoration: const InputDecoration(
                        hintText: 'Select violation type',
                      ),
                      isExpanded: true,
                      items: [
                        ..._types.map(
                          (t) => DropdownMenuItem(
                            value: t.typeId,
                            child: Row(
                              children: [
                                Expanded(
                                  child: Text(
                                    t.typeName,
                                    overflow: TextOverflow.ellipsis,
                                  ),
                                ),
                                const SizedBox(width: 6),
                                _SeverityDot(severity: t.severity),
                              ],
                            ),
                          ),
                        ),
                        DropdownMenuItem(
                          value: -1,
                          child: Row(
                            children: [
                              const Icon(Icons.add_circle_outline, size: 18),
                              const SizedBox(width: 6),
                              Text(
                                'Add new type…',
                                style: GoogleFonts.prompt(
                                  fontStyle: FontStyle.italic,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ],
                      onChanged: (val) {
                        if (val == -1) {
                          _addNewType();
                        } else {
                          setState(() => _selectedTypeId = val);
                        }
                      },
                      validator: (val) => (val == null || val == -1)
                          ? 'Please select a violation type'
                          : null,
                    ),

                    const SizedBox(height: 20),

                    // ── Reporter Name ──────────────────────────────────
                    _buildSectionLabel(theme, Icons.person_outline, 'Reporter'),
                    const SizedBox(height: 8),
                    TextFormField(
                      controller: _reporterCtrl,
                      decoration: const InputDecoration(
                        hintText: 'Enter reporter name',
                      ),
                      validator: (val) => (val == null || val.trim().isEmpty)
                          ? 'Please enter a name'
                          : null,
                    ),

                    const SizedBox(height: 20),

                    // ── Description ─────────────────────────────────────
                    _buildSectionLabel(
                      theme,
                      Icons.notes_outlined,
                      'Description',
                    ),
                    const SizedBox(height: 8),
                    TextFormField(
                      controller: _descriptionCtrl,
                      decoration: const InputDecoration(
                        hintText: 'Describe the incident...',
                        alignLabelWithHint: true,
                      ),
                      maxLines: 4,
                      validator: (val) => (val == null || val.trim().isEmpty)
                          ? 'Please enter a description'
                          : null,
                    ),

                    const SizedBox(height: 28),

                    // ── Submit ──────────────────────────────────────────
                    FilledButton.icon(
                      onPressed: _isSaving ? null : _submit,
                      icon: _isSaving
                          ? const SizedBox(
                              width: 18,
                              height: 18,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                color: Colors.white,
                              ),
                            )
                          : const Icon(Icons.send_rounded),
                      label: Text(
                        _isSaving ? 'Saving...' : 'Submit Report',
                        style: GoogleFonts.prompt(fontWeight: FontWeight.w600),
                      ),
                    ),
                  ],
                ),
              ),
            ),
    );
  }

  Widget _buildSectionLabel(ThemeData theme, IconData icon, String text) {
    return Row(
      children: [
        Icon(icon, size: 18, color: theme.colorScheme.primary),
        const SizedBox(width: 8),
        Text(
          text,
          style: GoogleFonts.prompt(
            fontSize: 14,
            fontWeight: FontWeight.w700,
            color: theme.colorScheme.onSurface,
          ),
        ),
      ],
    );
  }

  Widget _buildImageSection(ThemeData theme, ColorScheme colorScheme) {
    return Card(
      clipBehavior: Clip.antiAlias,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          // ── Image preview / placeholder ──────────────────────────────
          if (_pickedImage != null)
            Stack(
              children: [
                ClipRRect(
                  borderRadius: const BorderRadius.vertical(
                    top: Radius.circular(16),
                  ),
                  child: Image.file(
                    File(_pickedImage!.path),
                    height: 220,
                    width: double.infinity,
                    fit: BoxFit.cover,
                  ),
                ),
                Positioned(
                  top: 8,
                  right: 8,
                  child: CircleAvatar(
                    radius: 18,
                    backgroundColor: Colors.black54,
                    child: IconButton(
                      icon: const Icon(
                        Icons.close,
                        size: 18,
                        color: Colors.white,
                      ),
                      onPressed: () => setState(() {
                        _pickedImage = null;
                        _aiPrediction = null;
                        _aiConfidence = 0.0;
                      }),
                      padding: EdgeInsets.zero,
                    ),
                  ),
                ),
              ],
            )
          else
            InkWell(
              onTap: _showImageSourceSheet,
              child: Container(
                height: 180,
                color: colorScheme.surfaceContainerHighest.withOpacity(0.3),
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(
                      Icons.add_a_photo_outlined,
                      size: 48,
                      color: colorScheme.onSurfaceVariant.withOpacity(0.5),
                    ),
                    const SizedBox(height: 12),
                    Text(
                      'Add Evidence Photo',
                      style: GoogleFonts.prompt(
                        fontSize: 16,
                        fontWeight: FontWeight.w600,
                        color: colorScheme.onSurfaceVariant.withOpacity(0.7),
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      'Take a photo or choose from gallery',
                      style: GoogleFonts.prompt(
                        fontSize: 12,
                        color: colorScheme.onSurfaceVariant.withOpacity(0.5),
                      ),
                    ),
                  ],
                ),
              ),
            ),

          // ── Action bar ──────────────────────────────────────────────
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                // Change / pick image button
                if (_pickedImage != null)
                  TextButton.icon(
                    onPressed: _showImageSourceSheet,
                    icon: const Icon(Icons.swap_horiz, size: 18),
                    label: const Text('Change'),
                    style: TextButton.styleFrom(
                      visualDensity: VisualDensity.compact,
                    ),
                  )
                else
                  const SizedBox.shrink(),

                // Analyze with AI button
                if (_pickedImage != null)
                  FilledButton.tonalIcon(
                    onPressed: _isAnalyzing ? null : _analyzeImage,
                    icon: _isAnalyzing
                        ? const SizedBox(
                            width: 16,
                            height: 16,
                            child: CircularProgressIndicator(strokeWidth: 2),
                          )
                        : const Icon(Icons.smart_toy_outlined, size: 18),
                    label: Text(
                      _isAnalyzing ? 'Analyzing…' : 'AI Analyze',
                      style: GoogleFonts.prompt(fontWeight: FontWeight.w600),
                    ),
                    style: FilledButton.styleFrom(
                      visualDensity: VisualDensity.compact,
                    ),
                  ),
              ],
            ),
          ),

          // ── AI result ───────────────────────────────────────────────
          if (_aiPrediction != null)
            Container(
              margin: const EdgeInsets.fromLTRB(12, 0, 12, 12),
              padding: const EdgeInsets.all(14),
              decoration: BoxDecoration(
                color: colorScheme.primaryContainer.withOpacity(0.3),
                borderRadius: BorderRadius.circular(12),
              ),
              child: Row(
                children: [
                  Icon(
                    Icons.smart_toy_rounded,
                    color: colorScheme.primary,
                    size: 22,
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          _aiPrediction!,
                          style: GoogleFonts.prompt(
                            fontSize: 14,
                            fontWeight: FontWeight.w700,
                          ),
                        ),
                        const SizedBox(height: 2),
                        Text(
                          'Confidence: ${(_aiConfidence * 100).toStringAsFixed(1)}%',
                          style: GoogleFonts.prompt(
                            fontSize: 12,
                            color: colorScheme.onSurfaceVariant,
                          ),
                        ),
                      ],
                    ),
                  ),
                  CircleAvatar(
                    radius: 20,
                    backgroundColor: _aiConfidence >= 0.8
                        ? AppTheme.severityLow.withOpacity(0.15)
                        : AppTheme.severityMedium.withOpacity(0.15),
                    child: Text(
                      '${(_aiConfidence * 100).toStringAsFixed(0)}%',
                      style: GoogleFonts.prompt(
                        fontSize: 12,
                        fontWeight: FontWeight.w800,
                        color: _aiConfidence >= 0.8
                            ? AppTheme.severityLow
                            : AppTheme.severityMedium,
                      ),
                    ),
                  ),
                ],
              ),
            ),
        ],
      ),
    );
  }
}

class _SeverityDot extends StatelessWidget {
  final String severity;

  const _SeverityDot({required this.severity});

  @override
  Widget build(BuildContext context) {
    final color = AppTheme.severityColor(severity);

    return Container(
      width: 10,
      height: 10,
      decoration: BoxDecoration(shape: BoxShape.circle, color: color),
    );
  }
}
</file>

<file path="final66133505/lib/features/report/presentation/page/edit_report_page.dart">
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:image_picker/image_picker.dart';
import 'package:logging/logging.dart';

import 'package:final66133505/core/database/database.dart';
import 'package:final66133505/core/di/injection.dart';
import 'package:final66133505/core/theme/app_theme.dart';
import 'package:final66133505/core/utils/image_storage.dart';
import 'package:final66133505/core/utils/tflite_classifier.dart';

class EditReportPage extends StatefulWidget {
  final int reportId;

  const EditReportPage({super.key, required this.reportId});

  @override
  State<EditReportPage> createState() => _EditReportPageState();
}

class _EditReportPageState extends State<EditReportPage> {
  static final _log = Logger('EditReportPage');

  final _formKey = GlobalKey<FormState>();
  final _descriptionCtrl = TextEditingController();
  final _reporterCtrl = TextEditingController();

  List<PollingStationEntity> _stations = [];
  List<ViolationTypeEntity> _types = [];

  int? _selectedStationId;
  int? _selectedTypeId;

  bool _isSaving = false;
  bool _isLoading = true;

  // Image
  final ImagePicker _picker = ImagePicker();
  String? _existingPhotoPath; // path already saved in DB
  XFile? _newPickedImage; // newly picked image (replaces existing)
  bool _isAnalyzing = false;
  String? _aiPrediction;
  double _aiConfidence = 0.0;

  // Original entity — used for copyWith on save
  IncidentReportEntity? _original;

  @override
  void initState() {
    super.initState();
    _loadData();
  }

  @override
  void dispose() {
    _descriptionCtrl.dispose();
    _reporterCtrl.dispose();
    super.dispose();
  }

  Future<void> _loadData() async {
    try {
      final report = await sl<IncidentReportRepository>().getById(
        widget.reportId,
      );
      final stations = await sl<PollingStationRepository>().getAll();
      final types = await sl<ViolationTypeRepository>().getAll();

      if (report == null) {
        if (mounted) {
          ScaffoldMessenger.of(
            context,
          ).showSnackBar(const SnackBar(content: Text('Report not found')));
          context.pop();
        }
        return;
      }

      _descriptionCtrl.text = report.description;
      _reporterCtrl.text = report.reporterName;

      setState(() {
        _original = report;
        _stations = stations;
        _types = types;
        _selectedStationId = report.stationId;
        _selectedTypeId = report.typeId;
        _existingPhotoPath = report.evidencePhoto;
        _aiPrediction = report.aiResult;
        _aiConfidence = report.aiConfidence;
        _isLoading = false;
      });
    } catch (e, s) {
      _log.severe('Failed to load report for edit', e, s);
      if (mounted) setState(() => _isLoading = false);
    }
  }

  Future<void> _pickImage(ImageSource source) async {
    try {
      final image = await _picker.pickImage(
        source: source,
        maxWidth: 1024,
        maxHeight: 1024,
        imageQuality: 85,
      );
      if (image != null) {
        final persistentPath = await ImageStorage.copyToTemp(image.path);
        setState(() {
          _newPickedImage = XFile(persistentPath);
          _aiPrediction = null;
          _aiConfidence = 0.0;
        });
        // Auto-predict immediately after picking
        _analyzeImage();
      }
    } catch (e) {
      _log.warning('Image pick failed: $e');
      if (mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text('Failed to pick image: $e')));
      }
    }
  }

  void _showImageSourceSheet() {
    showModalBottomSheet(
      context: context,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (ctx) => SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(vertical: 16),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Container(
                width: 40,
                height: 4,
                decoration: BoxDecoration(
                  color: Colors.grey.shade300,
                  borderRadius: BorderRadius.circular(2),
                ),
              ),
              const SizedBox(height: 16),
              Text(
                'Select Image Source',
                style: GoogleFonts.prompt(
                  fontSize: 16,
                  fontWeight: FontWeight.w700,
                ),
              ),
              const SizedBox(height: 16),
              ListTile(
                leading: CircleAvatar(
                  backgroundColor: Theme.of(ctx).colorScheme.primaryContainer,
                  child: Icon(
                    Icons.camera_alt_rounded,
                    color: Theme.of(ctx).colorScheme.primary,
                  ),
                ),
                title: Text('Camera', style: GoogleFonts.prompt()),
                subtitle: Text(
                  'Take a new photo',
                  style: GoogleFonts.prompt(fontSize: 12),
                ),
                onTap: () {
                  Navigator.pop(ctx);
                  _pickImage(ImageSource.camera);
                },
              ),
              ListTile(
                leading: CircleAvatar(
                  backgroundColor: Theme.of(ctx).colorScheme.secondaryContainer,
                  child: Icon(
                    Icons.photo_library_rounded,
                    color: Theme.of(ctx).colorScheme.secondary,
                  ),
                ),
                title: Text('Gallery', style: GoogleFonts.prompt()),
                subtitle: Text(
                  'Choose from gallery',
                  style: GoogleFonts.prompt(fontSize: 12),
                ),
                onTap: () {
                  Navigator.pop(ctx);
                  _pickImage(ImageSource.gallery);
                },
              ),
              if (_existingPhotoPath != null || _newPickedImage != null)
                ListTile(
                  leading: CircleAvatar(
                    backgroundColor: AppTheme.severityHigh.withOpacity(0.1),
                    child: Icon(
                      Icons.delete_outline,
                      color: AppTheme.severityHigh,
                    ),
                  ),
                  title: Text(
                    'Remove photo',
                    style: GoogleFonts.prompt(color: AppTheme.severityHigh),
                  ),
                  onTap: () {
                    Navigator.pop(ctx);
                    setState(() {
                      _newPickedImage = null;
                      _existingPhotoPath = null;
                      _aiPrediction = null;
                      _aiConfidence = 0.0;
                    });
                  },
                ),
            ],
          ),
        ),
      ),
    );
  }

  void _showErrorDialog(String title, String message) {
    if (!mounted) return;
    showDialog<void>(
      context: context,
      builder: (ctx) => AlertDialog(
        icon: const Icon(Icons.error_outline_rounded, color: Colors.red, size: 40),
        title: Text(title, style: GoogleFonts.prompt(fontWeight: FontWeight.w700)),
        content: Text(message, style: GoogleFonts.prompt()),
        actions: [
          FilledButton(
            onPressed: () => Navigator.of(ctx).pop(),
            child: const Text('OK'),
          ),
        ],
      ),
    );
  }

  Future<void> _analyzeImage() async {
    final hasImage =
        _newPickedImage != null || ImageStorage.exists(_existingPhotoPath);
    if (!hasImage) return;

    setState(() => _isAnalyzing = true);

    try {
      final path = _newPickedImage?.path ?? _existingPhotoPath!;
      await tfliteClassifier.init();
      final result = await tfliteClassifier.classify(File(path));

      if (result != null) {
        setState(() {
          _aiPrediction = result.label;
          _aiConfidence = result.confidence;
        });
      } else {
        if (mounted) {
          _showErrorDialog(
            'Analysis Failed',
            'Could not classify this image.\nPlease try a clearer photo.',
          );
        }
      }
    } catch (e) {
      _log.warning('AI analysis error: $e');
      if (mounted) {
        _showErrorDialog('AI Error', 'Image analysis encountered an error:\n$e');
      }
    } finally {
      if (mounted) setState(() => _isAnalyzing = false);
    }
  }

  // ── Add-new dialogs ─────────────────────────────────────────────────

  Future<void> _addNewStation() async {
    final idCtrl = TextEditingController();
    final nameCtrl = TextEditingController();
    final zoneCtrl = TextEditingController();
    final provinceCtrl = TextEditingController();
    final formKey = GlobalKey<FormState>();

    try {
      final confirmed = await showDialog<bool>(
        context: context,
        builder: (ctx) => AlertDialog(
          title: Text(
            'New Polling Station',
            style: GoogleFonts.prompt(fontWeight: FontWeight.w700),
          ),
          content: SingleChildScrollView(
            child: Form(
              key: formKey,
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  TextFormField(
                    controller: idCtrl,
                    autofocus: true,
                    keyboardType: TextInputType.number,
                    decoration: const InputDecoration(
                      labelText: 'Station ID *',
                      hintText: 'e.g. 101',
                    ),
                    validator: (v) {
                      if (v == null || v.trim().isEmpty) return 'Required';
                      final parsed = int.tryParse(v.trim());
                      if (parsed == null) return 'Must be a number';
                      if (parsed <= 0) return 'Must be > 0';
                      if (_stations.any((s) => s.stationId == parsed)) {
                        return 'ID $parsed already exists';
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 8),
                  TextFormField(
                    controller: nameCtrl,
                    decoration:
                        const InputDecoration(labelText: 'Station name *'),
                    validator: (v) =>
                        (v == null || v.trim().isEmpty) ? 'Required' : null,
                  ),
                  const SizedBox(height: 8),
                  TextFormField(
                    controller: zoneCtrl,
                    decoration: const InputDecoration(labelText: 'Zone *'),
                    validator: (v) =>
                        (v == null || v.trim().isEmpty) ? 'Required' : null,
                  ),
                  const SizedBox(height: 8),
                  TextFormField(
                    controller: provinceCtrl,
                    decoration: const InputDecoration(labelText: 'Province *'),
                    validator: (v) =>
                        (v == null || v.trim().isEmpty) ? 'Required' : null,
                  ),
                ],
              ),
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(ctx).pop(false),
              child: const Text('Cancel'),
            ),
            FilledButton(
              onPressed: () {
                if (formKey.currentState!.validate()) {
                  Navigator.of(ctx).pop(true);
                }
              },
              child: const Text('Add'),
            ),
          ],
        ),
      );

      if (confirmed == true && mounted) {
        final newStation = await sl<PollingStationRepository>().create(
          stationId: int.tryParse(idCtrl.text.trim()),
          name: nameCtrl.text,
          zone: zoneCtrl.text,
          province: provinceCtrl.text,
        );
        if (mounted) {
          setState(() {
            // Remove any stale entry with the same ID before appending
            _stations = [
              ..._stations.where((s) => s.stationId != newStation.stationId),
              newStation,
            ];
            _selectedStationId = newStation.stationId;
          });
        }
      }
    } catch (e) {
      if (mounted) {
        _showErrorDialog('Failed to add station', e.toString());
      }
    }
    // Do NOT dispose — dialog close animation runs on the next frame and
    // the TextFormField widgets still hold references to these controllers.
  }

  Future<void> _addNewType() async {
    final nameCtrl = TextEditingController();
    String selectedSeverity = 'Medium';
    final formKey = GlobalKey<FormState>();

    try {
      final confirmed = await showDialog<bool>(
        context: context,
        builder: (ctx) => StatefulBuilder(
          builder: (ctx, setInner) => AlertDialog(
            title: Text(
              'New Violation Type',
              style: GoogleFonts.prompt(fontWeight: FontWeight.w700),
            ),
            content: Form(
              key: formKey,
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  TextFormField(
                    controller: nameCtrl,
                    autofocus: true,
                    decoration: const InputDecoration(
                      labelText: 'Violation name *',
                    ),
                    validator: (v) =>
                        (v == null || v.trim().isEmpty) ? 'Required' : null,
                  ),
                  const SizedBox(height: 12),
                  DropdownButtonFormField<String>(
                    value: selectedSeverity,
                    decoration: const InputDecoration(labelText: 'Severity'),
                    items: const [
                      DropdownMenuItem(value: 'High', child: Text('High')),
                      DropdownMenuItem(
                        value: 'Medium',
                        child: Text('Medium'),
                      ),
                      DropdownMenuItem(value: 'Low', child: Text('Low')),
                    ],
                    onChanged: (v) => setInner(() => selectedSeverity = v!),
                  ),
                ],
              ),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(ctx).pop(false),
                child: const Text('Cancel'),
              ),
              FilledButton(
                onPressed: () {
                  if (formKey.currentState!.validate()) {
                    Navigator.of(ctx).pop(true);
                  }
                },
                child: const Text('Add'),
              ),
            ],
          ),
        ),
      );

      if (confirmed == true && mounted) {
        final newType = await sl<ViolationTypeRepository>().create(
          name: nameCtrl.text,
          severity: selectedSeverity,
        );
        if (mounted) {
          setState(() {
            _types = [..._types, newType];
            _selectedTypeId = newType.typeId;
          });
        }
      }
    } catch (e) {
      if (mounted) {
        _showErrorDialog('Failed to add violation type', e.toString());
      }
    }
    // Do NOT dispose — same reason as _addNewStation above.
  }

  Future<void> _submit() async {
    if (!_formKey.currentState!.validate()) return;
    if (_selectedStationId == null || _selectedTypeId == null) return;
    if (_original == null) return;

    setState(() => _isSaving = true);

    try {
      // Use new image path if picked, else keep existing
      final photoPath = _newPickedImage?.path ?? _existingPhotoPath;

      final updated = _original!.copyWith(
        stationId: _selectedStationId,
        typeId: _selectedTypeId,
        reporterName: _reporterCtrl.text.trim(),
        description: _descriptionCtrl.text.trim(),
        evidencePhoto: photoPath,
        aiResult: _aiPrediction,
        aiConfidence: _aiConfidence,
      );

      await sl<IncidentReportRepository>().update(updated);
      sl<AutoSyncManager>().requestSync();

      _log.info('Report ${widget.reportId} updated');

      if (mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(const SnackBar(content: Text('Report updated ✓')));
        context.pop(true);
      }
    } catch (e, s) {
      _log.severe('Failed to update report', e, s);
      if (mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text('Failed to update: $e')));
      }
    } finally {
      if (mounted) setState(() => _isSaving = false);
    }
  }

  // ── Active photo path ────────────────────────────────────────────────────

  String? get _activePhotoPath => _newPickedImage?.path ?? _existingPhotoPath;

  bool get _hasPhoto => ImageStorage.exists(_activePhotoPath);

  // ─────────────────────────────────────────────────────────────────────────

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final cs = theme.colorScheme;

    return Scaffold(
      appBar: AppBar(
        title: Text(
          'Edit Report #${widget.reportId}',
          style: GoogleFonts.prompt(fontWeight: FontWeight.w700),
        ),
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : SingleChildScrollView(
              padding: const EdgeInsets.fromLTRB(20, 8, 20, 32),
              child: Form(
                key: _formKey,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    // ── Evidence Photo ──────────────────────────────────
                    _buildImageSection(theme, cs),

                    const SizedBox(height: 16),

                    // ── Polling Station ─────────────────────────────────
                    _buildSectionLabel(
                      theme,
                      Icons.how_to_vote_outlined,
                      'Polling Station',
                    ),
                    const SizedBox(height: 8),
                    DropdownButtonFormField<int>(
                      value: _selectedStationId,
                      decoration: const InputDecoration(
                        hintText: 'Select a polling station',
                      ),
                      isExpanded: true,
                      items: [
                        ..._stations.map(
                          (s) => DropdownMenuItem(
                            value: s.stationId,
                            child: Text(
                              '${s.stationName} (${s.zone})',
                              overflow: TextOverflow.ellipsis,
                            ),
                          ),
                        ),
                        DropdownMenuItem(
                          value: -1,
                          child: Row(
                            children: [
                              const Icon(Icons.add_circle_outline, size: 18),
                              const SizedBox(width: 6),
                              Text(
                                'Add new station…',
                                style: GoogleFonts.prompt(
                                  fontStyle: FontStyle.italic,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ],
                      onChanged: (val) {
                        if (val == -1) {
                          _addNewStation();
                        } else {
                          setState(() => _selectedStationId = val);
                        }
                      },
                      validator: (val) => (val == null || val == -1)
                          ? 'Please select a station'
                          : null,
                    ),

                    const SizedBox(height: 20),

                    // ── Violation Type ──────────────────────────────────
                    _buildSectionLabel(
                      theme,
                      Icons.gavel_outlined,
                      'Violation Type',
                    ),
                    const SizedBox(height: 8),
                    DropdownButtonFormField<int>(
                      value: _selectedTypeId,
                      decoration: const InputDecoration(
                        hintText: 'Select violation type',
                      ),
                      isExpanded: true,
                      items: [
                        ..._types.map(
                          (t) => DropdownMenuItem(
                            value: t.typeId,
                            child: Row(
                              children: [
                                Expanded(
                                  child: Text(
                                    t.typeName,
                                    overflow: TextOverflow.ellipsis,
                                  ),
                                ),
                                const SizedBox(width: 6),
                                _SeverityDot(severity: t.severity),
                              ],
                            ),
                          ),
                        ),
                        DropdownMenuItem(
                          value: -1,
                          child: Row(
                            children: [
                              const Icon(Icons.add_circle_outline, size: 18),
                              const SizedBox(width: 6),
                              Text(
                                'Add new type…',
                                style: GoogleFonts.prompt(
                                  fontStyle: FontStyle.italic,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ],
                      onChanged: (val) {
                        if (val == -1) {
                          _addNewType();
                        } else {
                          setState(() => _selectedTypeId = val);
                        }
                      },
                      validator: (val) => (val == null || val == -1)
                          ? 'Please select a violation type'
                          : null,
                    ),

                    const SizedBox(height: 20),

                    // ── Reporter Name ───────────────────────────────────
                    _buildSectionLabel(theme, Icons.person_outline, 'Reporter'),
                    const SizedBox(height: 8),
                    TextFormField(
                      controller: _reporterCtrl,
                      decoration: const InputDecoration(
                        hintText: 'Enter reporter name',
                      ),
                      validator: (val) => (val == null || val.trim().isEmpty)
                          ? 'Please enter a name'
                          : null,
                    ),

                    const SizedBox(height: 20),

                    // ── Description ─────────────────────────────────────
                    _buildSectionLabel(
                      theme,
                      Icons.notes_outlined,
                      'Description',
                    ),
                    const SizedBox(height: 8),
                    TextFormField(
                      controller: _descriptionCtrl,
                      decoration: const InputDecoration(
                        hintText: 'Describe the incident...',
                        alignLabelWithHint: true,
                      ),
                      maxLines: 4,
                      validator: (val) => (val == null || val.trim().isEmpty)
                          ? 'Please enter a description'
                          : null,
                    ),

                    const SizedBox(height: 28),

                    // ── Save ────────────────────────────────────────────
                    FilledButton.icon(
                      onPressed: _isSaving ? null : _submit,
                      icon: _isSaving
                          ? const SizedBox(
                              width: 18,
                              height: 18,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                color: Colors.white,
                              ),
                            )
                          : const Icon(Icons.save_rounded),
                      label: Text(
                        _isSaving ? 'Saving...' : 'Save Changes',
                        style: GoogleFonts.prompt(fontWeight: FontWeight.w600),
                      ),
                    ),
                  ],
                ),
              ),
            ),
    );
  }

  Widget _buildSectionLabel(ThemeData theme, IconData icon, String text) {
    return Row(
      children: [
        Icon(icon, size: 18, color: theme.colorScheme.primary),
        const SizedBox(width: 8),
        Text(
          text,
          style: GoogleFonts.prompt(
            fontSize: 14,
            fontWeight: FontWeight.w700,
            color: theme.colorScheme.onSurface,
          ),
        ),
      ],
    );
  }

  Widget _buildImageSection(ThemeData theme, ColorScheme cs) {
    return Card(
      clipBehavior: Clip.antiAlias,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          // ── Image preview / placeholder ──────────────────────────────
          if (_hasPhoto)
            Stack(
              children: [
                ClipRRect(
                  borderRadius: const BorderRadius.vertical(
                    top: Radius.circular(16),
                  ),
                  child: Image.file(
                    File(_activePhotoPath!),
                    height: 220,
                    width: double.infinity,
                    fit: BoxFit.cover,
                    errorBuilder: (_, __, ___) => _imagePlaceholder(cs),
                  ),
                ),
                Positioned(
                  top: 8,
                  right: 8,
                  child: CircleAvatar(
                    radius: 18,
                    backgroundColor: Colors.black54,
                    child: IconButton(
                      icon: const Icon(
                        Icons.close,
                        size: 18,
                        color: Colors.white,
                      ),
                      onPressed: () => setState(() {
                        _newPickedImage = null;
                        _existingPhotoPath = null;
                        _aiPrediction = null;
                        _aiConfidence = 0.0;
                      }),
                      padding: EdgeInsets.zero,
                    ),
                  ),
                ),
              ],
            )
          else
            InkWell(onTap: _showImageSourceSheet, child: _imagePlaceholder(cs)),

          // ── Action bar ──────────────────────────────────────────────
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                if (_hasPhoto)
                  TextButton.icon(
                    onPressed: _showImageSourceSheet,
                    icon: const Icon(Icons.swap_horiz, size: 18),
                    label: Text('Change', style: GoogleFonts.prompt()),
                    style: TextButton.styleFrom(
                      visualDensity: VisualDensity.compact,
                    ),
                  )
                else
                  const SizedBox.shrink(),
                if (_hasPhoto)
                  FilledButton.tonalIcon(
                    onPressed: _isAnalyzing ? null : _analyzeImage,
                    icon: _isAnalyzing
                        ? const SizedBox(
                            width: 16,
                            height: 16,
                            child: CircularProgressIndicator(strokeWidth: 2),
                          )
                        : const Icon(Icons.smart_toy_outlined, size: 18),
                    label: Text(
                      _isAnalyzing ? 'Analyzing…' : 'AI Analyze',
                      style: GoogleFonts.prompt(fontWeight: FontWeight.w600),
                    ),
                    style: FilledButton.styleFrom(
                      visualDensity: VisualDensity.compact,
                    ),
                  ),
              ],
            ),
          ),

          // ── AI result ───────────────────────────────────────────────
          if (_aiPrediction != null)
            Container(
              margin: const EdgeInsets.fromLTRB(12, 0, 12, 12),
              padding: const EdgeInsets.all(14),
              decoration: BoxDecoration(
                color: cs.primaryContainer.withOpacity(0.3),
                borderRadius: BorderRadius.circular(12),
              ),
              child: Row(
                children: [
                  Icon(Icons.smart_toy_rounded, color: cs.primary, size: 22),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          _aiPrediction!,
                          style: GoogleFonts.prompt(
                            fontSize: 14,
                            fontWeight: FontWeight.w700,
                          ),
                        ),
                        const SizedBox(height: 2),
                        Text(
                          'Confidence: ${(_aiConfidence * 100).toStringAsFixed(1)}%',
                          style: GoogleFonts.prompt(
                            fontSize: 12,
                            color: cs.onSurfaceVariant,
                          ),
                        ),
                      ],
                    ),
                  ),
                  CircleAvatar(
                    radius: 20,
                    backgroundColor: _aiConfidence >= 0.8
                        ? AppTheme.severityLow.withOpacity(0.15)
                        : AppTheme.severityMedium.withOpacity(0.15),
                    child: Text(
                      '${(_aiConfidence * 100).toStringAsFixed(0)}%',
                      style: GoogleFonts.prompt(
                        fontSize: 12,
                        fontWeight: FontWeight.w800,
                        color: _aiConfidence >= 0.8
                            ? AppTheme.severityLow
                            : AppTheme.severityMedium,
                      ),
                    ),
                  ),
                ],
              ),
            ),
        ],
      ),
    );
  }

  Widget _imagePlaceholder(ColorScheme cs) {
    return Container(
      height: 180,
      color: cs.surfaceContainerHighest.withOpacity(0.3),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.add_a_photo_outlined,
            size: 48,
            color: cs.onSurfaceVariant.withOpacity(0.5),
          ),
          const SizedBox(height: 12),
          Text(
            'Add Evidence Photo',
            style: GoogleFonts.prompt(
              fontSize: 16,
              fontWeight: FontWeight.w600,
              color: cs.onSurfaceVariant.withOpacity(0.7),
            ),
          ),
          const SizedBox(height: 4),
          Text(
            'Take a photo or choose from gallery',
            style: GoogleFonts.prompt(
              fontSize: 12,
              color: cs.onSurfaceVariant.withOpacity(0.5),
            ),
          ),
        ],
      ),
    );
  }
}

// ─── Severity Dot ─────────────────────────────────────────────────────────────

class _SeverityDot extends StatelessWidget {
  final String severity;
  const _SeverityDot({required this.severity});

  @override
  Widget build(BuildContext context) {
    return Container(
      width: 10,
      height: 10,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        color: AppTheme.severityColor(severity),
      ),
    );
  }
}
</file>

<file path="final66133505/lib/features/report/presentation/page/report_detail_page.dart">
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:logging/logging.dart';
import 'package:intl/intl.dart';

import 'package:final66133505/core/database/database.dart';
import 'package:final66133505/core/di/injection.dart';
import 'package:final66133505/core/theme/app_theme.dart';
import 'package:final66133505/core/utils/image_storage.dart';

class ReportDetailPage extends StatefulWidget {
  final int reportId;

  const ReportDetailPage({super.key, required this.reportId});

  @override
  State<ReportDetailPage> createState() => _ReportDetailPageState();
}

class _ReportDetailPageState extends State<ReportDetailPage> {
  static final _log = Logger('ReportDetailPage');

  final IncidentReportRepository _reportRepo = sl<IncidentReportRepository>();
  final PollingStationRepository _stationRepo = sl<PollingStationRepository>();
  final ViolationTypeRepository _typeRepo = sl<ViolationTypeRepository>();

  IncidentReportEntity? _report;
  PollingStationEntity? _station;
  ViolationTypeEntity? _violationType;
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _load();
  }

  Future<void> _load() async {
    setState(() => _isLoading = true);
    try {
      final report = await _reportRepo.getById(widget.reportId);
      PollingStationEntity? station;
      ViolationTypeEntity? violationType;

      if (report != null) {
        station = await _stationRepo.getById(report.stationId);
        violationType = await _typeRepo.getById(report.typeId);
      }

      setState(() {
        _report = report;
        _station = station;
        _violationType = violationType;
        _isLoading = false;
      });
    } catch (e, s) {
      _log.severe('Failed to load report detail', e, s);
      setState(() => _isLoading = false);
    }
  }

  Future<void> _deleteReport() async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        icon: const Icon(Icons.delete_outline, color: Colors.red, size: 36),
        title: const Text('Delete Report'),
        content: const Text(
          'Are you sure you want to delete this incident report? '
          'This action cannot be undone.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(false),
            child: const Text('Cancel'),
          ),
          FilledButton(
            onPressed: () => Navigator.of(ctx).pop(true),
            style: FilledButton.styleFrom(backgroundColor: Colors.red),
            child: const Text('Delete'),
          ),
        ],
      ),
    );

    if (confirmed == true && mounted) {
      try {
        await _reportRepo.delete(widget.reportId);

        // Push deletion to Firestore and notify dashboard.
        sl<AutoSyncManager>().requestSync();

        if (mounted) {
          ScaffoldMessenger.of(
            context,
          ).showSnackBar(const SnackBar(content: Text('Report deleted ✓')));
          context.pop(true);
        }
      } catch (e) {
        if (mounted) {
          ScaffoldMessenger.of(
            context,
          ).showSnackBar(SnackBar(content: Text('Delete failed: $e')));
        }
      }
    }
  }

  Color get _severityColor {
    final sev = _violationType?.severity ?? '';
    return AppTheme.severityColor(sev);
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Scaffold(
      appBar: AppBar(
        title: Text(
          'Report #${widget.reportId}',
          style: GoogleFonts.prompt(fontWeight: FontWeight.w700),
        ),
        actions: [
          IconButton(
            onPressed: () async {
              final updated = await context.push(
                '/reports/edit/${widget.reportId}',
              );
              if (updated == true && mounted) _load();
            },
            icon: const Icon(Icons.edit_outlined),
            tooltip: 'Edit report',
          ),
          IconButton(
            onPressed: _deleteReport,
            icon: const Icon(Icons.delete_outline),
            tooltip: 'Delete report',
            color: AppTheme.severityHigh,
          ),
        ],
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _report == null
          ? _buildNotFound(theme)
          : _buildDetail(theme, colorScheme),
    );
  }

  Widget _buildNotFound(ThemeData theme) {
    return Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            Icons.search_off,
            size: 64,
            color: theme.colorScheme.outlineVariant,
          ),
          const SizedBox(height: 16),
          Text(
            'Report not found',
            style: GoogleFonts.prompt(
              fontSize: 16,
              fontWeight: FontWeight.w600,
              color: theme.colorScheme.onSurfaceVariant,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildDetail(ThemeData theme, ColorScheme colorScheme) {
    final report = _report!;
    final date = DateTime.tryParse(report.timestamp) ?? DateTime.now();

    return SingleChildScrollView(
      padding: const EdgeInsets.fromLTRB(20, 8, 20, 32),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // ── Sync Banner ──────────────────────────────────────────────
          _SyncBanner(isSynced: report.isSynced),

          const SizedBox(height: 20),

          // ── Incident Info ────────────────────────────────────────────
          _SectionCard(
            icon: Icons.article_outlined,
            title: 'Incident Details',
            colorScheme: colorScheme,
            children: [
              _DetailRow('Report ID', '#${report.reportId}', icon: Icons.tag),
              _DetailRow(
                'Reporter',
                report.reporterName,
                icon: Icons.person_outline,
              ),
              _DetailRow(
                'Date & Time',
                DateFormat('dd MMMM yyyy, HH:mm').format(date),
                icon: Icons.schedule,
              ),
              const Divider(height: 20),
              Text(
                'Description',
                style: GoogleFonts.prompt(
                  fontSize: 12,
                  fontWeight: FontWeight.w600,
                  color: colorScheme.onSurfaceVariant,
                ),
              ),
              const SizedBox(height: 6),
              Text(
                report.description,
                style: GoogleFonts.prompt(fontSize: 14, height: 1.5),
              ),
              if (report.evidencePhoto != null) ...[
                const SizedBox(height: 12),
                _EvidenceImage(path: report.evidencePhoto!),
              ],
            ],
          ),

          const SizedBox(height: 12),

          // ── AI Analysis ──────────────────────────────────────────────
          _SectionCard(
            icon: Icons.smart_toy_outlined,
            title: 'AI Analysis',
            colorScheme: colorScheme,
            children: [
              _DetailRow(
                'Prediction',
                report.aiResult ?? 'N/A',
                icon: Icons.analytics_outlined,
              ),
              const SizedBox(height: 8),
              Row(
                children: [
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          'Confidence',
                          style: GoogleFonts.prompt(
                            fontSize: 12,
                            fontWeight: FontWeight.w600,
                            color: colorScheme.onSurfaceVariant,
                          ),
                        ),
                        const SizedBox(height: 6),
                        ClipRRect(
                          borderRadius: BorderRadius.circular(6),
                          child: LinearProgressIndicator(
                            value: report.aiConfidence,
                            minHeight: 10,
                            backgroundColor:
                                colorScheme.surfaceContainerHighest,
                            color: report.aiConfidence >= 0.8
                                ? AppTheme.severityLow
                                : report.aiConfidence >= 0.5
                                ? AppTheme.severityMedium
                                : AppTheme.severityHigh,
                          ),
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(width: 16),
                  Text(
                    report.aiConfidence > 0
                        ? '${(report.aiConfidence * 100).toStringAsFixed(1)}%'
                        : 'N/A',
                    style: GoogleFonts.prompt(
                      fontSize: 18,
                      fontWeight: FontWeight.w800,
                      color: report.aiConfidence >= 0.8
                          ? AppTheme.severityLow
                          : report.aiConfidence >= 0.5
                          ? AppTheme.severityMedium
                          : AppTheme.severityHigh,
                    ),
                  ),
                ],
              ),
            ],
          ),

          const SizedBox(height: 12),

          // ── Station + Violation side by side ─────────────────────────
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Expanded(
                child: _SectionCard(
                  icon: Icons.how_to_vote_outlined,
                  title: 'Station',
                  colorScheme: colorScheme,
                  children: _station != null
                      ? [
                          Text(
                            _station!.stationName,
                            style: GoogleFonts.prompt(
                              fontSize: 14,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                          const SizedBox(height: 4),
                          Text(
                            '${_station!.zone}\n${_station!.province}',
                            style: GoogleFonts.prompt(
                              fontSize: 12,
                              color: colorScheme.onSurfaceVariant,
                            ),
                          ),
                        ]
                      : [Text('Station #${report.stationId}')],
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: _SectionCard(
                  icon: Icons.gavel_outlined,
                  title: 'Violation',
                  colorScheme: colorScheme,
                  children: _violationType != null
                      ? [
                          Text(
                            _violationType!.typeName,
                            style: GoogleFonts.prompt(
                              fontSize: 14,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                          const SizedBox(height: 6),
                          Container(
                            padding: const EdgeInsets.symmetric(
                              horizontal: 8,
                              vertical: 3,
                            ),
                            decoration: BoxDecoration(
                              color: _severityColor.withOpacity(0.12),
                              borderRadius: BorderRadius.circular(8),
                              border: Border.all(
                                color: _severityColor.withOpacity(0.3),
                              ),
                            ),
                            child: Text(
                              _violationType!.severity,
                              style: GoogleFonts.prompt(
                                fontSize: 12,
                                fontWeight: FontWeight.w700,
                                color: _severityColor,
                              ),
                            ),
                          ),
                        ]
                      : [Text('Type #${report.typeId}')],
                ),
              ),
            ],
          ),

          const SizedBox(height: 28),

          // ── Action Buttons ───────────────────────────────────────────
          Row(
            children: [
              // Delete — left-aligned, destructive
              OutlinedButton.icon(
                onPressed: _deleteReport,
                icon: const Icon(Icons.delete_outline, size: 18),
                label: Text('Delete', style: GoogleFonts.prompt()),
                style: OutlinedButton.styleFrom(
                  foregroundColor: AppTheme.severityHigh,
                  side: BorderSide(
                    color: AppTheme.severityHigh.withOpacity(0.6),
                  ),
                  padding: const EdgeInsets.symmetric(
                    horizontal: 16,
                    vertical: 12,
                  ),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12),
                  ),
                ),
              ),

              const SizedBox(width: 12),
              const Spacer(),
              const SizedBox(width: 12),

              // Edit — right-aligned, primary CTA
              FilledButton.icon(
                onPressed: () async {
                  final updated = await context.push(
                    '/reports/edit/${widget.reportId}',
                  );
                  if (updated == true && mounted) _load();
                },
                icon: const Icon(Icons.edit_outlined, size: 18),
                label: Text(
                  'Edit Report',
                  style: GoogleFonts.prompt(fontWeight: FontWeight.w600),
                ),
                style: FilledButton.styleFrom(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 20,
                    vertical: 12,
                  ),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12),
                  ),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

// ─── Sync Banner ─────────────────────────────────────────────────────────────

class _SyncBanner extends StatelessWidget {
  final bool isSynced;
  const _SyncBanner({required this.isSynced});

  @override
  Widget build(BuildContext context) {
    final color = isSynced ? AppTheme.syncedColor : AppTheme.pendingColor;
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: color.withOpacity(0.3)),
      ),
      child: Row(
        children: [
          Icon(
            isSynced ? Icons.cloud_done_rounded : Icons.cloud_off_rounded,
            color: color,
            size: 20,
          ),
          const SizedBox(width: 10),
          Expanded(
            child: Text(
              isSynced
                  ? 'Synced to Firebase'
                  : 'Pending sync — will upload when online',
              style: GoogleFonts.prompt(
                color: color,
                fontWeight: FontWeight.w500,
                fontSize: 13,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

// ─── Section Card ────────────────────────────────────────────────────────────

class _SectionCard extends StatelessWidget {
  final IconData icon;
  final String title;
  final ColorScheme colorScheme;
  final List<Widget> children;

  const _SectionCard({
    required this.icon,
    required this.title,
    required this.colorScheme,
    required this.children,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(icon, size: 18, color: colorScheme.primary),
                const SizedBox(width: 8),
                Text(
                  title,
                  style: GoogleFonts.prompt(
                    fontSize: 13,
                    fontWeight: FontWeight.w700,
                    color: colorScheme.primary,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),
            ...children,
          ],
        ),
      ),
    );
  }
}

// ─── Detail Row ──────────────────────────────────────────────────────────────

class _DetailRow extends StatelessWidget {
  final String label;
  final String value;
  final IconData? icon;

  const _DetailRow(this.label, this.value, {this.icon});

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          if (icon != null) ...[
            Icon(icon, size: 16, color: cs.onSurfaceVariant),
            const SizedBox(width: 8),
          ],
          SizedBox(
            width: 90,
            child: Text(
              label,
              style: GoogleFonts.prompt(
                fontSize: 12,
                color: cs.onSurfaceVariant,
              ),
            ),
          ),
          Expanded(
            child: Text(
              value,
              style: GoogleFonts.prompt(
                fontSize: 14,
                fontWeight: FontWeight.w500,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

// ─── Evidence Image ───────────────────────────────────────────────────────────

class _EvidenceImage extends StatelessWidget {
  final String path;
  const _EvidenceImage({required this.path});

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    final fileExists = ImageStorage.exists(path);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Icon(Icons.image_outlined, size: 16, color: cs.onSurfaceVariant),
            const SizedBox(width: 6),
            Text(
              'Evidence Photo',
              style: GoogleFonts.prompt(
                fontSize: 12,
                fontWeight: FontWeight.w600,
                color: cs.onSurfaceVariant,
              ),
            ),
          ],
        ),
        const SizedBox(height: 8),
        ClipRRect(
          borderRadius: BorderRadius.circular(12),
          child: fileExists
              ? Image.file(
                  File(path),
                  width: double.infinity,
                  height: 220,
                  fit: BoxFit.cover,
                  errorBuilder: (_, __, ___) => _placeholder(cs),
                )
              : _placeholder(cs),
        ),
      ],
    );
  }

  Widget _placeholder(ColorScheme cs) {
    return Container(
      width: double.infinity,
      height: 120,
      decoration: BoxDecoration(
        color: cs.surfaceContainerHighest.withOpacity(0.4),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.broken_image_outlined, size: 40, color: cs.outlineVariant),
          const SizedBox(height: 8),
          Text(
            'Image not available',
            style: GoogleFonts.prompt(fontSize: 12, color: cs.outlineVariant),
          ),
        ],
      ),
    );
  }
}
</file>

<file path="final66133505/lib/features/report/presentation/page/report_page.dart">
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:logging/logging.dart';

import 'package:final66133505/core/database/database.dart';
import 'package:final66133505/core/di/injection.dart';
import 'package:final66133505/core/theme/app_theme.dart';
import '../../domain/entities/incident_report.dart';
import '../widgets/incident_report_card.dart';

class ReportPage extends StatefulWidget {
  const ReportPage({super.key});

  @override
  State<ReportPage> createState() => _ReportPageState();
}

class _ReportPageState extends State<ReportPage> {
  final IncidentReportRepository _reportRepo = sl<IncidentReportRepository>();
  final PollingStationRepository _stationRepo = sl<PollingStationRepository>();
  final ViolationTypeRepository _typeRepo = sl<ViolationTypeRepository>();

  static final _log = Logger('ReportPage');

  List<IncidentReport> _reports = [];
  bool _isLoading = true;
  String? _error;
  SyncStatus _syncStatus = const SyncStatus();

  StreamSubscription<SyncStatus>? _syncSub;

  @override
  void initState() {
    super.initState();
    _loadReports();

    // Auto-refresh when background sync completes.
    final syncManager = sl<AutoSyncManager>();
    _syncStatus = syncManager.currentStatus;
    _syncSub = syncManager.statusStream.listen((status) {
      final wasNotSynced = _syncStatus.state != SyncState.synced;
      if (mounted) setState(() => _syncStatus = status);
      if (status.state == SyncState.synced && wasNotSynced && mounted) {
        _loadReports();
      }
    });
  }

  @override
  void dispose() {
    _syncSub?.cancel();
    super.dispose();
  }

  Future<void> _loadReports() async {
    setState(() {
      _isLoading = true;
      _error = null;
    });

    try {
      await _reportRepo.pullFromFirestore();

      final entities = await _reportRepo.getAll();
      final stations = await _stationRepo.getAll();
      final types = await _typeRepo.getAll();

      final stationMap = {for (final s in stations) s.stationId: s};
      final typeMap = {for (final t in types) t.typeId: t};

      final reports = entities.map((e) {
        final station = stationMap[e.stationId];
        final type = typeMap[e.typeId];

        return IncidentReport(
          id: e.reportId ?? 0,
          description: e.description,
          date: DateTime.tryParse(e.timestamp) ?? DateTime.now(),
          reporterName: e.reporterName,
          stationId: e.stationId,
          stationName: station?.stationName ?? 'Station #${e.stationId}',
          zone: station?.zone ?? '-',
          province: station?.province ?? '-',
          typeId: e.typeId,
          violationTypeName: type?.typeName ?? 'Type #${e.typeId}',
          severity: type?.severity ?? 'Low',
          aiResult: e.aiResult,
          aiConfidence: e.aiConfidence,
          evidencePhoto: e.evidencePhoto,
          isSynced: e.isSynced,
        );
      }).toList();

      _log.info('Loaded ${reports.length} reports');

      setState(() {
        _reports = reports;
        _isLoading = false;
      });
    } catch (e, s) {
      _log.severe('Failed to load reports', e, s);
      setState(() {
        _error = e.toString();
        _isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Scaffold(
      body: Column(
        children: [
          // ── Sync status banner ──────────────────────────────────────
          _buildSyncBanner(colorScheme),

          // ── Body ────────────────────────────────────────────────────
          Expanded(child: _buildBody(theme, colorScheme)),
        ],
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () async {
          final result = await context.push('/reports/add');
          if (result == true) _loadReports();
        },
        icon: const Icon(Icons.add_rounded),
        label: Text(
          'New Report',
          style: GoogleFonts.prompt(fontWeight: FontWeight.w600),
        ),
      ),
    );
  }

  Widget _buildSyncBanner(ColorScheme colorScheme) {
    // Only show when there's something interesting to report.
    if (_syncStatus.state == SyncState.idle && !_syncStatus.hasPending) {
      return const SizedBox.shrink();
    }

    final (
      Color bg,
      Color fg,
      IconData icon,
      String text,
    ) = switch (_syncStatus.state) {
      SyncState.syncing => (
        const Color(0xFFE3F2FD),
        const Color(0xFF0D47A1),
        Icons.sync_rounded,
        'Syncing with server…',
      ),
      SyncState.synced => (
        AppTheme.syncedColor.withOpacity(0.1),
        AppTheme.syncedColor,
        Icons.cloud_done_rounded,
        'All reports synced ✓',
      ),
      SyncState.offline => (
        AppTheme.offlineColor.withOpacity(0.1),
        AppTheme.offlineColor,
        Icons.cloud_off_rounded,
        'Offline — changes saved locally',
      ),
      SyncState.error => (
        AppTheme.severityHigh.withOpacity(0.1),
        AppTheme.severityHigh,
        Icons.sync_problem_rounded,
        'Sync failed — tap to retry',
      ),
      SyncState.idle when _syncStatus.hasPending => (
        AppTheme.pendingColor.withOpacity(0.1),
        AppTheme.pendingColor,
        Icons.cloud_upload_outlined,
        '${_syncStatus.pendingCount} report${_syncStatus.pendingCount > 1 ? "s" : ""} pending sync',
      ),
      _ => (Colors.transparent, Colors.transparent, Icons.sync, ''),
    };

    if (text.isEmpty) return const SizedBox.shrink();

    return Material(
      color: bg,
      child: InkWell(
        onTap: () => sl<AutoSyncManager>().requestSync(),
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10),
          child: Row(
            children: [
              if (_syncStatus.isSyncing)
                SizedBox(
                  width: 16,
                  height: 16,
                  child: CircularProgressIndicator(strokeWidth: 2, color: fg),
                )
              else
                Icon(icon, size: 18, color: fg),
              const SizedBox(width: 10),
              Expanded(
                child: Text(
                  text,
                  style: GoogleFonts.prompt(
                    color: fg,
                    fontWeight: FontWeight.w500,
                    fontSize: 13,
                  ),
                ),
              ),
              if (_syncStatus.hasPending && !_syncStatus.isSyncing)
                Text(
                  'Sync',
                  style: GoogleFonts.prompt(
                    color: fg,
                    fontWeight: FontWeight.w700,
                    fontSize: 13,
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildBody(ThemeData theme, ColorScheme colorScheme) {
    if (_isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    if (_error != null) {
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(32),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(Icons.error_outline, color: AppTheme.severityHigh, size: 56),
              const SizedBox(height: 16),
              Text(
                'Failed to load reports',
                style: GoogleFonts.prompt(
                  fontSize: 16,
                  fontWeight: FontWeight.w600,
                ),
              ),
              const SizedBox(height: 8),
              Text(
                _error!,
                textAlign: TextAlign.center,
                style: GoogleFonts.prompt(
                  fontSize: 12,
                  color: colorScheme.onSurfaceVariant,
                ),
              ),
              const SizedBox(height: 20),
              FilledButton.icon(
                onPressed: _loadReports,
                icon: const Icon(Icons.refresh),
                label: Text('Retry', style: GoogleFonts.prompt()),
              ),
            ],
          ),
        ),
      );
    }

    if (_reports.isEmpty) {
      return Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              Icons.how_to_vote_outlined,
              size: 72,
              color: colorScheme.primary.withOpacity(0.2),
            ),
            const SizedBox(height: 16),
            Text(
              'No incident reports',
              style: GoogleFonts.prompt(
                fontSize: 16,
                fontWeight: FontWeight.w600,
                color: colorScheme.onSurfaceVariant,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              'Tap + to create your first report',
              style: GoogleFonts.prompt(
                fontSize: 13,
                color: colorScheme.onSurfaceVariant.withOpacity(0.7),
              ),
            ),
            const SizedBox(height: 20),
            OutlinedButton.icon(
              onPressed: _loadReports,
              icon: const Icon(Icons.refresh),
              label: Text('Refresh', style: GoogleFonts.prompt()),
            ),
          ],
        ),
      );
    }

    return RefreshIndicator(
      onRefresh: _loadReports,
      child: ListView.builder(
        padding: const EdgeInsets.only(top: 8, bottom: 88, left: 4, right: 4),
        itemCount: _reports.length,
        itemBuilder: (context, index) {
          final report = _reports[index];
          return IncidentReportCard(
            report: report,
            onTap: () async {
              final result = await context.push('/reports/detail/${report.id}');
              if (result == true) _loadReports();
            },
          );
        },
      ),
    );
  }
}
</file>

<file path="final66133505/lib/features/report/presentation/widgets/incident_report_card.dart">
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

import 'package:final66133505/core/theme/app_theme.dart';
import '../../domain/entities/incident_report.dart';

class IncidentReportCard extends StatelessWidget {
  final IncidentReport report;
  final VoidCallback? onTap;

  const IncidentReportCard({super.key, required this.report, this.onTap});

  Color get _severityColor => AppTheme.severityColor(report.severity);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final cs = theme.colorScheme;

    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 5),
      clipBehavior: Clip.antiAlias,
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(16),
        child: IntrinsicHeight(
          child: Row(
            children: [
              // ── Severity indicator bar ──────────────────────────────
              Container(
                width: 5,
                decoration: BoxDecoration(
                  gradient: LinearGradient(
                    begin: Alignment.topCenter,
                    end: Alignment.bottomCenter,
                    colors: [_severityColor, _severityColor.withOpacity(0.6)],
                  ),
                ),
              ),

              // ── Content ─────────────────────────────────────────────
              Expanded(
                child: Padding(
                  padding: const EdgeInsets.fromLTRB(14, 14, 14, 12),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      // Header: title + severity badge
                      Row(
                        children: [
                          Expanded(
                            child: Text(
                              report.title,
                              style: GoogleFonts.prompt(
                                fontSize: 14,
                                fontWeight: FontWeight.w700,
                                color: cs.onSurface,
                              ),
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                            ),
                          ),
                          const SizedBox(width: 8),
                          _SeverityChip(
                            severity: report.severity,
                            color: _severityColor,
                          ),
                        ],
                      ),

                      const SizedBox(height: 6),

                      // Description
                      Text(
                        report.description,
                        style: GoogleFonts.prompt(
                          fontSize: 12,
                          color: cs.onSurfaceVariant,
                          height: 1.4,
                        ),
                        maxLines: 2,
                        overflow: TextOverflow.ellipsis,
                      ),

                      const SizedBox(height: 10),

                      // Info chips
                      Wrap(
                        spacing: 6,
                        runSpacing: 4,
                        children: [
                          _InfoChip(
                            icon: Icons.how_to_vote_outlined,
                            label: report.stationName,
                          ),
                          if (report.aiResult != null &&
                              report.aiResult!.isNotEmpty)
                            _InfoChip(
                              icon: Icons.smart_toy_outlined,
                              label:
                                  '${report.aiResult} ${(report.aiConfidence * 100).toStringAsFixed(0)}%',
                            ),
                        ],
                      ),

                      const SizedBox(height: 10),

                      // Footer: person + date + sync
                      Row(
                        children: [
                          Icon(
                            Icons.person_outline,
                            size: 14,
                            color: cs.onSurfaceVariant,
                          ),
                          const SizedBox(width: 3),
                          Expanded(
                            child: Text(
                              report.reporterName,
                              style: GoogleFonts.prompt(
                                fontSize: 11,
                                color: cs.onSurfaceVariant,
                              ),
                              overflow: TextOverflow.ellipsis,
                            ),
                          ),
                          Icon(
                            Icons.schedule,
                            size: 14,
                            color: cs.onSurfaceVariant,
                          ),
                          const SizedBox(width: 3),
                          Text(
                            _formatDate(report.date),
                            style: GoogleFonts.prompt(
                              fontSize: 11,
                              color: cs.onSurfaceVariant,
                            ),
                          ),
                          const SizedBox(width: 8),
                          Icon(
                            report.isSynced
                                ? Icons.cloud_done_outlined
                                : Icons.cloud_off_outlined,
                            size: 15,
                            color: report.isSynced
                                ? AppTheme.syncedColor
                                : AppTheme.pendingColor,
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  String _formatDate(DateTime dt) {
    return '${dt.day.toString().padLeft(2, '0')}/'
        '${dt.month.toString().padLeft(2, '0')}/'
        '${dt.year} '
        '${dt.hour.toString().padLeft(2, '0')}:'
        '${dt.minute.toString().padLeft(2, '0')}';
  }
}

// ─── Severity Chip ───────────────────────────────────────────────────────────

class _SeverityChip extends StatelessWidget {
  final String severity;
  final Color color;

  const _SeverityChip({required this.severity, required this.color});

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 3),
      decoration: BoxDecoration(
        color: color.withOpacity(0.12),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: color.withOpacity(0.3)),
      ),
      child: Text(
        severity,
        style: GoogleFonts.prompt(
          fontSize: 11,
          fontWeight: FontWeight.w700,
          color: color,
        ),
      ),
    );
  }
}

// ─── Info Chip ───────────────────────────────────────────────────────────────

class _InfoChip extends StatelessWidget {
  final IconData icon;
  final String label;

  const _InfoChip({required this.icon, required this.label});

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: cs.primaryContainer.withOpacity(0.3),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 13, color: cs.primary),
          const SizedBox(width: 4),
          Flexible(
            child: Text(
              label,
              style: GoogleFonts.prompt(
                fontSize: 11,
                color: cs.onSurfaceVariant,
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ),
        ],
      ),
    );
  }
}
</file>

<file path="final66133505/lib/router/app_router.dart">
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import '../features/dashboard/presentation/page/home.dart';
import '../features/analysis/presentation/page/ai_scanner.dart';
import '../features/report/presentation/page/report_page.dart';
import '../features/report/presentation/page/report_detail_page.dart';
import '../features/report/presentation/page/add_report_page.dart';
import '../features/report/presentation/page/edit_report_page.dart';
import '../shared/layouts/main_layout.dart';

// Keys for each navigation branch — keeps each tab's state alive.
final _rootNavigatorKey = GlobalKey<NavigatorState>();
final _homeNavigatorKey = GlobalKey<NavigatorState>(debugLabel: 'home');
final _analysisNavigatorKey = GlobalKey<NavigatorState>(debugLabel: 'analysis');
final _reportsNavigatorKey = GlobalKey<NavigatorState>(debugLabel: 'reports');

final GoRouter router = GoRouter(
  navigatorKey: _rootNavigatorKey,
  initialLocation: '/',
  routes: [
    // ── Stateful shell — preserves each tab's navigation stack ──────────
    StatefulShellRoute.indexedStack(
      builder: (context, state, navigationShell) {
        return MainLayout(navigationShell: navigationShell);
      },
      branches: [
        // Tab 0 — Dashboard
        StatefulShellBranch(
          navigatorKey: _homeNavigatorKey,
          routes: [
            GoRoute(path: '/', builder: (context, state) => const MyHomePage()),
          ],
        ),
        // Tab 1 — AI Scanner
        StatefulShellBranch(
          navigatorKey: _analysisNavigatorKey,
          routes: [
            GoRoute(
              path: '/analysis',
              builder: (context, state) => const AiScanner(),
            ),
          ],
        ),
        // Tab 2 — Reports
        StatefulShellBranch(
          navigatorKey: _reportsNavigatorKey,
          routes: [
            GoRoute(
              path: '/reports',
              builder: (context, state) => const ReportPage(),
            ),
          ],
        ),
      ],
    ),

    // ── Full-screen pages (outside shell — own Scaffold, back button) ───
    GoRoute(
      parentNavigatorKey: _rootNavigatorKey,
      path: '/reports/detail/:id',
      builder: (context, state) {
        final id = int.tryParse(state.pathParameters['id'] ?? '') ?? 0;
        return ReportDetailPage(reportId: id);
      },
    ),
    GoRoute(
      parentNavigatorKey: _rootNavigatorKey,
      path: '/reports/add',
      builder: (context, state) => const AddReportPage(),
    ),
    GoRoute(
      parentNavigatorKey: _rootNavigatorKey,
      path: '/reports/edit/:id',
      builder: (context, state) {
        final id = int.tryParse(state.pathParameters['id'] ?? '') ?? 0;
        return EditReportPage(reportId: id);
      },
    ),
  ],
);
</file>

<file path="final66133505/lib/shared/layouts/main_layout.dart">
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:logging/logging.dart';
import 'package:final66133505/core/database/app_database.dart';
import 'package:final66133505/core/database/database.dart';
import 'package:final66133505/core/di/injection.dart';

class MainLayout extends StatefulWidget {
  const MainLayout({super.key, required this.navigationShell});

  final StatefulNavigationShell navigationShell;

  @override
  State<MainLayout> createState() => _MainLayoutState();
}

class _MainLayoutState extends State<MainLayout> {
  static final _log = Logger('MainLayout');

  static const _titles = ['Election Monitor', 'AI Scanner', 'Reports'];

  static const _navItems = [
    NavigationDestination(
      icon: Icon(Icons.dashboard_outlined),
      selectedIcon: Icon(Icons.dashboard_rounded),
      label: 'Dashboard',
    ),
    NavigationDestination(
      icon: Icon(Icons.document_scanner_outlined),
      selectedIcon: Icon(Icons.document_scanner_rounded),
      label: 'AI Scanner',
    ),
    NavigationDestination(
      icon: Icon(Icons.assignment_outlined),
      selectedIcon: Icon(Icons.assignment_rounded),
      label: 'Reports',
    ),
  ];

  late final AutoSyncManager _syncManager;
  StreamSubscription<SyncStatus>? _syncSub;
  SyncStatus _syncStatus = const SyncStatus();

  @override
  void initState() {
    super.initState();
    _syncManager = sl<AutoSyncManager>();
    _syncStatus = _syncManager.currentStatus;
    _syncSub = _syncManager.statusStream.listen((status) {
      if (mounted) setState(() => _syncStatus = status);
    });
  }

  @override
  void dispose() {
    _syncSub?.cancel();
    super.dispose();
  }

  // ── reset database ─────────────────────────────────────────────────────

  Future<void> _confirmAndReset() async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        icon: const Icon(
          Icons.warning_amber_rounded,
          color: Colors.orange,
          size: 40,
        ),
        title: const Text('Reset Database'),
        content: const Text(
          'This will delete ALL local data and restore the original seed data.\n\n'
          'Synced data in Firestore will NOT be affected.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(false),
            child: const Text('Cancel'),
          ),
          FilledButton(
            onPressed: () => Navigator.of(ctx).pop(true),
            style: FilledButton.styleFrom(backgroundColor: Colors.red),
            child: const Text('Reset'),
          ),
        ],
      ),
    );

    if (confirmed != true || !mounted) return;

    final scaffoldMsg = ScaffoldMessenger.of(context);
    scaffoldMsg.showSnackBar(
      const SnackBar(
        content: Row(
          children: [
            SizedBox(
              width: 18,
              height: 18,
              child: CircularProgressIndicator(
                strokeWidth: 2,
                color: Colors.white,
              ),
            ),
            SizedBox(width: 14),
            Text('Resetting database…'),
          ],
        ),
        duration: Duration(seconds: 10),
      ),
    );

    try {
      await sl<AppDatabase>().resetDatabase();
      _log.info('Database reset complete');

      scaffoldMsg.hideCurrentSnackBar();
      scaffoldMsg.showSnackBar(
        const SnackBar(
          content: Text('✅ Database reset — seed data restored'),
          backgroundColor: Colors.green,
          duration: Duration(seconds: 3),
        ),
      );

      // Trigger a sync after reset.
      _syncManager.requestSync();

      if (mounted) widget.navigationShell.goBranch(0);
    } catch (e, s) {
      _log.severe('Database reset failed', e, s);
      scaffoldMsg.hideCurrentSnackBar();
      scaffoldMsg.showSnackBar(
        SnackBar(
          content: Text('❌ Reset failed: $e'),
          backgroundColor: Colors.red,
          duration: const Duration(seconds: 4),
        ),
      );
    }
  }

  // ── build ──────────────────────────────────────────────────────────────

  @override
  Widget build(BuildContext context) {
    final currentIndex = widget.navigationShell.currentIndex;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Scaffold(
      appBar: AppBar(
        title: Text(
          _titles[currentIndex],
          style: GoogleFonts.prompt(fontWeight: FontWeight.w700, fontSize: 20),
        ),
        centerTitle: false,
        surfaceTintColor: colorScheme.surfaceTint,
        actions: [
          // ── Live sync status chip ──────────────────────────────────
          _SyncStatusChip(
            status: _syncStatus,
            onTap: () => _syncManager.requestSync(),
          ),
          const SizedBox(width: 4),
          IconButton(
            onPressed: _confirmAndReset,
            icon: const Icon(Icons.restart_alt_rounded),
            tooltip: 'Reset Database',
          ),
        ],
      ),
      body: widget.navigationShell,
      bottomNavigationBar: NavigationBar(
        selectedIndex: currentIndex,
        onDestinationSelected: (index) {
          widget.navigationShell.goBranch(
            index,
            initialLocation: index == widget.navigationShell.currentIndex,
          );
        },
        labelBehavior: NavigationDestinationLabelBehavior.alwaysShow,
        destinations: _navItems,
      ),
    );
  }
}

// ═════════════════════════════════════════════════════════════════════════════
// Sync status chip — shown in AppBar
// ═════════════════════════════════════════════════════════════════════════════

class _SyncStatusChip extends StatelessWidget {
  final SyncStatus status;
  final VoidCallback onTap;

  const _SyncStatusChip({required this.status, required this.onTap});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    final (IconData icon, Color color, String label) = switch (status.state) {
      SyncState.syncing => (Icons.sync_rounded, colorScheme.primary, 'Syncing'),
      SyncState.synced => (
        Icons.cloud_done_rounded,
        Colors.green.shade600,
        'Synced',
      ),
      SyncState.offline => (
        Icons.cloud_off_rounded,
        Colors.grey.shade600,
        'Offline',
      ),
      SyncState.error => (
        Icons.sync_problem_rounded,
        Colors.red.shade600,
        'Error',
      ),
      SyncState.idle when status.hasPending => (
        Icons.cloud_upload_rounded,
        Colors.orange.shade600,
        '${status.pendingCount}',
      ),
      SyncState.idle => (Icons.cloud_done_outlined, Colors.green.shade600, ''),
    };

    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(20),
        child: Tooltip(
          message: _tooltipMessage,
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                if (status.isSyncing)
                  SizedBox(
                    width: 16,
                    height: 16,
                    child: CircularProgressIndicator(
                      strokeWidth: 2,
                      color: color,
                    ),
                  )
                else
                  Icon(icon, size: 18, color: color),
                if (label.isNotEmpty) ...[
                  const SizedBox(width: 4),
                  Text(
                    label,
                    style: TextStyle(
                      fontSize: 11,
                      fontWeight: FontWeight.w600,
                      color: color,
                    ),
                  ),
                ],
              ],
            ),
          ),
        ),
      ),
    );
  }

  String get _tooltipMessage {
    return switch (status.state) {
      SyncState.syncing => 'Syncing with server…',
      SyncState.synced => 'All data synced',
      SyncState.offline => 'Offline — data saved locally',
      SyncState.error =>
        'Sync error: ${status.errorMessage ?? "unknown"}. Tap to retry.',
      SyncState.idle when status.hasPending =>
        '${status.pendingCount} report${status.pendingCount > 1 ? "s" : ""} pending sync. Tap to sync.',
      SyncState.idle => 'All data synced',
    };
  }
}
</file>

<file path="final66133505/lib/shared/widgets/splash_screen.dart">
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

/// Full-screen splash shown while the app is booting and pulling from Firestore.
///
/// Receives a [Future] that resolves when startup is done. Once the future
/// completes, [onReady] is called and the caller can navigate to the main shell.
class SplashScreen extends StatefulWidget {
  const SplashScreen({
    super.key,
    required this.startupFuture,
    required this.onReady,
  });

  /// The async work to wait for (Firestore pull, DI init, etc.).
  final Future<void> Function() startupFuture;

  /// Called once [startupFuture] resolves. Navigate to the main app here.
  final VoidCallback onReady;

  @override
  State<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends State<SplashScreen>
    with SingleTickerProviderStateMixin {
  late final AnimationController _pulseCtrl;
  late final Animation<double> _pulseAnim;

  String _statusMessage = 'Initializing…';
  bool _isDone = false;

  @override
  void initState() {
    super.initState();

    _pulseCtrl = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1200),
    )..repeat(reverse: true);

    _pulseAnim = Tween<double>(
      begin: 0.6,
      end: 1.0,
    ).animate(CurvedAnimation(parent: _pulseCtrl, curve: Curves.easeInOut));

    _runStartup();
  }

  Future<void> _runStartup() async {
    _setStatus('Connecting to server…');
    try {
      await widget.startupFuture();
      _setStatus('Ready!');
      _isDone = true;
      // Brief pause so "Ready!" is visible before transition.
      await Future.delayed(const Duration(milliseconds: 400));
      if (mounted) widget.onReady();
    } catch (_) {
      _setStatus('Starting offline…');
      await Future.delayed(const Duration(milliseconds: 600));
      if (mounted) widget.onReady();
    }
  }

  void _setStatus(String msg) {
    if (mounted) setState(() => _statusMessage = msg);
  }

  @override
  void dispose() {
    _pulseCtrl.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;

    return Scaffold(
      backgroundColor: cs.surface,
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            // ── Animated logo / icon ─────────────────────────────────
            AnimatedBuilder(
              animation: _pulseAnim,
              builder: (_, __) => Transform.scale(
                scale: _pulseAnim.value,
                child: Container(
                  width: 100,
                  height: 100,
                  decoration: BoxDecoration(
                    color: cs.primaryContainer,
                    shape: BoxShape.circle,
                    boxShadow: [
                      BoxShadow(
                        color: cs.primary.withOpacity(0.25),
                        blurRadius: 32,
                        spreadRadius: 4,
                      ),
                    ],
                  ),
                  child: Icon(
                    Icons.how_to_vote_rounded,
                    size: 52,
                    color: cs.primary,
                  ),
                ),
              ),
            ),

            const SizedBox(height: 32),

            // ── App name ─────────────────────────────────────────────
            Text(
              'Election Monitor',
              style: GoogleFonts.prompt(
                fontSize: 24,
                fontWeight: FontWeight.w800,
                color: cs.onSurface,
              ),
            ),

            const SizedBox(height: 6),

            Text(
              'Incident Reporting System',
              style: GoogleFonts.prompt(
                fontSize: 14,
                color: cs.onSurfaceVariant,
              ),
            ),

            const SizedBox(height: 48),

            // ── Progress indicator ───────────────────────────────────
            if (!_isDone)
              SizedBox(
                width: 200,
                child: LinearProgressIndicator(
                  borderRadius: BorderRadius.circular(8),
                  color: cs.primary,
                  backgroundColor: cs.primaryContainer,
                ),
              ),

            if (_isDone)
              Icon(
                Icons.check_circle_rounded,
                color: Colors.green.shade600,
                size: 28,
              ),

            const SizedBox(height: 16),

            // ── Status message ───────────────────────────────────
            AnimatedSwitcher(
              duration: const Duration(milliseconds: 300),
              child: Text(
                _statusMessage,
                key: ValueKey(_statusMessage),
                style: GoogleFonts.prompt(
                  fontSize: 12,
                  color: cs.onSurfaceVariant,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
</file>

<file path="final66133505/lib/main.dart">
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/material.dart';
import 'package:logging/logging.dart';
import 'core/di/injection.dart';
import 'core/database/database.dart';
import 'core/constants/firebase_options.dart';
import 'core/theme/app_theme.dart';
import 'router/app_router.dart';
import 'shared/widgets/splash_screen.dart';

final _log = Logger('MyApp');

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  Logger.root.level = Level.ALL;
  Logger.root.onRecord.listen((record) {
    // ignore: avoid_print
    print('${record.level.name}: ${record.time}: ${record.message}');
    if (record.error != null) {
      // ignore: avoid_print
      print('  ERROR: ${record.error}');
    }
    if (record.stackTrace != null) {
      // ignore: avoid_print
      print('  STACK: ${record.stackTrace}');
    }
  });

  _log.info('App starting...');

  // 1. Firebase must be ready before anything else.
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);

  // 2. Register all singletons (DB, data sources, repos, sync manager).
  await configureDependencies();

  _log.info('Firebase & DI ready — showing splash');

  runApp(const MyApp());
}

// ─────────────────────────────────────────────────────────────────────────────
// Root app
// ─────────────────────────────────────────────────────────────────────────────

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  bool _startupDone = false;

  /// All heavy async work that must finish before the main shell is shown.
  ///
  /// Runs inside the SplashScreen so the user sees progress feedback.
  Future<void> _startup() async {
    // Step 1 — Ensure Firestore ↔ SQLite seed integrity.
    await _ensureFirestoreSeeded();

    // Step 2 — Pull latest data from Firestore → SQLite (startup pull-first).
    //           Always runs; gracefully skips if offline.
    _log.info('Startup pull from Firestore…');
    await sl<SyncService>().pullFromFirestoreOnStartup();
    _log.info('Startup pull done');

    // Step 3 — Start the auto-sync manager (periodic + lifecycle-aware).
    await sl<AutoSyncManager>().initialize();

    _log.info('Startup sequence complete ✓');
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Election Incident Monitor',
      debugShowCheckedModeBanner: false,
      theme: AppTheme.light,
      // Show splash while loading; swap to the router shell when done.
      home: _startupDone
          ? _RouterShell()
          : SplashScreen(
              startupFuture: _startup,
              onReady: () => setState(() => _startupDone = true),
            ),
    );
  }
}

/// Thin wrapper that hands off to the go_router configuration.
class _RouterShell extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      routerConfig: router,
      title: 'Election Incident Monitor',
      debugShowCheckedModeBanner: false,
      theme: Theme.of(context),
    );
  }
}

// ---------------------------------------------------------------------------
// Firestore seed check — production safe
// ---------------------------------------------------------------------------

/// Ensures bidirectional seed integrity between SQLite and Firestore.
///
/// Order matters: reference data (stations, types) is resolved FIRST so that
/// incident reports can satisfy their foreign-key constraints.
///
/// For each collection:
///   - If Firestore is empty BUT SQLite has data → push SQLite → Firestore.
///   - If Firestore has data BUT SQLite is empty → pull Firestore → SQLite.
///   - If both have data → nothing to do (regular sync handles merges).
///   - If both empty → the SQLite `_onCreate` seed should have run by now;
///     re-check and push if local data appeared.
Future<void> _ensureFirestoreSeeded() async {
  final firestore = FirebaseFirestore.instance;

  try {
    // ────────────────────────────────────────────────────────────────────────
    // STEP 1 — Reference data (must come first for FK integrity)
    // ────────────────────────────────────────────────────────────────────────

    // ── polling_stations ─────────────────────────────────────────────────
    final stationRepo = sl<PollingStationRepository>();
    // Calling getAll() ensures the DB is opened (triggers _onCreate + seed).
    var localStations = await stationRepo.getAll();
    final stationsSnap = await firestore
        .collection('polling_stations')
        .limit(1)
        .get();

    if (stationsSnap.docs.isEmpty && localStations.isNotEmpty) {
      _log.info(
        'Firestore: polling_stations empty, SQLite has ${localStations.length} → pushing',
      );
      await stationRepo.pushAllToFirestore();
    } else if (stationsSnap.docs.isNotEmpty && localStations.isEmpty) {
      _log.info('Firestore: polling_stations has data, SQLite empty → pulling');
      await stationRepo.pullFromFirestore();
    } else if (stationsSnap.docs.isEmpty && localStations.isEmpty) {
      _log.warning(
        'Firestore & SQLite both empty for polling_stations — no seed data available',
      );
    } else {
      _log.fine('Firestore: polling_stations — both sides have data ✓');
    }

    // ── violation_types ──────────────────────────────────────────────────
    final typeRepo = sl<ViolationTypeRepository>();
    var localTypes = await typeRepo.getAll();
    final typesSnap = await firestore
        .collection('violation_types')
        .limit(1)
        .get();

    if (typesSnap.docs.isEmpty && localTypes.isNotEmpty) {
      _log.info(
        'Firestore: violation_types empty, SQLite has ${localTypes.length} → pushing',
      );
      await typeRepo.pushAllToFirestore();
    } else if (typesSnap.docs.isNotEmpty && localTypes.isEmpty) {
      _log.info('Firestore: violation_types has data, SQLite empty → pulling');
      await typeRepo.pullFromFirestore();
    } else if (typesSnap.docs.isEmpty && localTypes.isEmpty) {
      _log.warning(
        'Firestore & SQLite both empty for violation_types — no seed data available',
      );
    } else {
      _log.fine('Firestore: violation_types — both sides have data ✓');
    }

    // ────────────────────────────────────────────────────────────────────────
    // STEP 2 — Incident reports (depends on reference data above)
    // ────────────────────────────────────────────────────────────────────────

    // Re-read reference data to confirm FK targets exist before pulling.
    localStations = await stationRepo.getAll();
    localTypes = await typeRepo.getAll();

    if (localStations.isEmpty || localTypes.isEmpty) {
      _log.warning(
        'Skipping incident_reports sync — reference data missing '
        '(stations: ${localStations.length}, types: ${localTypes.length})',
      );
      return;
    }

    final reportRepo = sl<IncidentReportRepository>();
    final localReports = await reportRepo.getAll();
    final reportsSnap = await firestore
        .collection('incident_reports')
        .limit(1)
        .get();

    if (reportsSnap.docs.isEmpty && localReports.isNotEmpty) {
      _log.info(
        'Firestore: incident_reports empty, SQLite has ${localReports.length} → pushing',
      );
      await reportRepo.pushAllToFirestore();
    } else if (reportsSnap.docs.isNotEmpty && localReports.isEmpty) {
      _log.info('Firestore: incident_reports has data, SQLite empty → pulling');
      await reportRepo.pullFromFirestore();
    } else if (reportsSnap.docs.isEmpty && localReports.isEmpty) {
      _log.fine(
        'Firestore & SQLite both empty for incident_reports — nothing to sync',
      );
    } else {
      _log.fine('Firestore: incident_reports — both sides have data ✓');
    }

    _log.info('Firestore seed check complete');
  } catch (e, s) {
    _log.severe('Firestore seed check failed (offline?)', e, s);
  }
}
</file>

</files>
